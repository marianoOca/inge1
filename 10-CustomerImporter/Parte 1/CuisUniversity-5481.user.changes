

----QUIT----(11 September 2022 19:10:09) CuisUniversity-5481.image priorSource: 2810882!

----STARTUP---- (11 September 2022 19:10:10) as /Users/hernan/Documents/Cuis/5.0-64Bits/Cuis-University-Installer/CuisUniversity-5481.image!


----QUIT----(11 September 2022 19:10:10) CuisUniversity-5481.image priorSource: 7059465!

----STARTUP---- (29 September 2022 18:30:15) as /home/clinux01/Escritorio/linux64/CuisUniversity-5481.image!


----End fileIn of /home/clinux01/Descargas/TDDBabyStepsGame.st----!

TDDBabyStepsGameRot13 start!

!classDefinition: #TDDBabyStepsRot13Test category: 'TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 18:31:03'!
TestCase subclass: #TDDBabyStepsRot13Test
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameRot13'!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:31:09'!
test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $n equals: $a asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:31:09'!
ERROR!

!methodRemoval: TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:31:09'!
test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $n equals: $a asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:31:09'!
test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $n equals: $a asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:31:09'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:31:18'!
ERROR!
!Character methodsFor: 'converting' stamp: 'MO 9/29/2022 18:31:24'!
asRot13
	self shouldBeImplemented.! !
!Character methodsFor: 'converting' stamp: 'MO 9/29/2022 18:31:42' prior: 50554042!
asRot13
	^ $n! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:31:44'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:31:44'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:31:46'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:31:46'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:31:46'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:31:46'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:31:46'!
test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $z equals: $m asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:31:46'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'MO 9/29/2022 18:32:26' prior: 50554046!
asRot13
	self = $m ifTrue: [$z].
	^ $n! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:32:27'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'MO 9/29/2022 18:32:40' prior: 50554092!
asRot13
	self = $m ifTrue: [^ $z].
	^ $n! !

!testRun: #CharacterTest #testCaseConversion stamp: 'MO 9/29/2022 18:32:41'!
PASSED!

!testRun: #CharacterTest #testFromUtf8 stamp: 'MO 9/29/2022 18:32:41'!
PASSED!

!testRun: #CharacterTest #testIsCharacter stamp: 'MO 9/29/2022 18:32:41'!
PASSED!

!testRun: #CharacterTest #testSomeLatinCharsFromUtf8 stamp: 'MO 9/29/2022 18:32:41'!
PASSED!

!testRun: #CharacterTest #testSomeLatinCharsToUtf8 stamp: 'MO 9/29/2022 18:32:41'!
PASSED!

!testRun: #CharacterTest #testSorting stamp: 'MO 9/29/2022 18:32:41'!
PASSED!

!testRun: #CharacterTest #testTestingMethods stamp: 'MO 9/29/2022 18:32:41'!
PASSED!

!testRun: #CharacterTest #testToUtf8 stamp: 'MO 9/29/2022 18:32:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:32:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:32:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:32:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:32:46'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:32:46'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:32:46'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:32:46'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:32:46'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:32:46'!
test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $a equals: $n asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:32:46'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'MO 9/29/2022 18:33:05' prior: 50554101!
asRot13

	self = $n ifTrue: [^ $a].
	self = $m ifTrue: [^ $z].
	^ $n! !

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:06'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:06'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:06'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:06'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:12'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:33:12'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:12'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:12'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:33:12'!
test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $m equals: $z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:12'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'MO 9/29/2022 18:33:31' prior: 50554177!
asRot13

	self = $z ifTrue: [^ $m].
	self = $n ifTrue: [^ $a].
	self = $m ifTrue: [^ $z].
	^ $n! !

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:35'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:35'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:35'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:33:35'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:33:35'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:33:35'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:33:35'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:33:35'!
test05CharOnTheBelowRangeDoesntChange
	
	self assert: $` equals: $` asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:33:35'!
FAILURE!
!Character methodsFor: 'converting' stamp: 'MO 9/29/2022 18:34:28' prior: 50554242!
asRot13

	"self = $ ifTrue: [^ $]."
	self = $` ifTrue: [^ $`].
	self = $z ifTrue: [^ $m].
	self = $n ifTrue: [^ $a].
	self = $m ifTrue: [^ $z].
	^ $n! !

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:36:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:36:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:36:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:36:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:36:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:36:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:36:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:36:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:36:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:36:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:36:52'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:36:52'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 18:36:52'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 18:36:52'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:36:52'!
test06CharOnTheUpperRangeDoesntChange
	
	self assert: ${ equals: ${ asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 18:36:52'!
FAILURE!
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 18:37:18' prior: 50554312!
asRot13

	"self = $ ifTrue: [^ $]."
	self = ${ ifTrue: [^ ${].
	self = $` ifTrue: [^ $`].
	self = $z ifTrue: [^ $m].
	self = $n ifTrue: [^ $a].
	self = $m ifTrue: [^ $z].
	^ $n! !

!testRun: #CharacterTest #testCaseConversion stamp: 'MO 9/29/2022 18:37:19'!
PASSED!

!testRun: #CharacterTest #testFromUtf8 stamp: 'MO 9/29/2022 18:37:19'!
PASSED!

!testRun: #CharacterTest #testIsCharacter stamp: 'MO 9/29/2022 18:37:19'!
PASSED!

!testRun: #CharacterTest #testSomeLatinCharsFromUtf8 stamp: 'MO 9/29/2022 18:37:19'!
PASSED!

!testRun: #CharacterTest #testSomeLatinCharsToUtf8 stamp: 'MO 9/29/2022 18:37:19'!
PASSED!

!testRun: #CharacterTest #testSorting stamp: 'MO 9/29/2022 18:37:19'!
PASSED!

!testRun: #CharacterTest #testTestingMethods stamp: 'MO 9/29/2022 18:37:19'!
PASSED!

!testRun: #CharacterTest #testToUtf8 stamp: 'MO 9/29/2022 18:37:19'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:37:21'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:37:21'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:37:21'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:37:21'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:37:21'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 18:37:21'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:37:21'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:37:21'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:37:21'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:37:21'!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:37:21'!
FAILURE!
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 18:40:08' prior: 50554391!
asRot13

	"self = $ ifTrue: [^ $]."
	self = $A ifTrue: [^ $N].
	self = $M ifTrue: [^ $Z].
	self = ${ ifTrue: [^ ${].
	self = $` ifTrue: [^ $`].
	self = $z ifTrue: [^ $m].
	self = $n ifTrue: [^ $a].
	self = $m ifTrue: [^ $z].
	^ $n! !
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:40:26' prior: 50554466!
test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet
	
	self assert: $N equals: $A asRot13.
	self assert: $Z equals: $M asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:40:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:40:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:40:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:40:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:40:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:40:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 18:40:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:40:32'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:40:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:40:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:40:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:40:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:40:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 18:40:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:40:33'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:40:33'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:40:33'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:40:33'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:40:33'!
test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet
	
	self assert: $A equals: $N asRot13.
	self assert: $M equals: $Z asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:40:33'!
FAILURE!
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 18:41:04' prior: 50554479!
asRot13

	"self = $ ifTrue: [^ $]."
	self = $A ifTrue: [^ $N].
	self = $M ifTrue: [^ $Z].
	self = $N ifTrue: [^ $A].
	self = $Z ifTrue: [^ $M].
	self = ${ ifTrue: [^ ${].
	self = $` ifTrue: [^ $`].
	self = $z ifTrue: [^ $m].
	self = $n ifTrue: [^ $a].
	self = $m ifTrue: [^ $z].
	^ $n! !

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:41:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:41:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:41:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:41:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:41:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:41:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 18:41:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:41:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:41:08'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:41:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:41:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:41:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:41:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:41:10'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 18:41:10'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:41:10'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:41:10'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:41:10'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 18:41:10'!
ERROR!

!methodRemoval: TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 18:41:10'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:41:10'!
test09TheEmptyStringDoesntChange
	
	self assert: '' equals: '' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 18:41:10'!
ERROR!
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 18:41:40' prior: 50554594!
asRot13

	"self = $ ifTrue: [^ $]."
	self = '' ifTrue: [^ ''].
	self = $A ifTrue: [^ $N].
	self = $M ifTrue: [^ $Z].
	self = $N ifTrue: [^ $A].
	self = $Z ifTrue: [^ $M].
	self = ${ ifTrue: [^ ${].
	self = $` ifTrue: [^ $`].
	self = $z ifTrue: [^ $m].
	self = $n ifTrue: [^ $a].
	self = $m ifTrue: [^ $z].
	^ $n! !

!testRun: #CharacterTest #testCaseConversion stamp: 'MO 9/29/2022 18:41:41'!
PASSED!

!testRun: #CharacterTest #testFromUtf8 stamp: 'MO 9/29/2022 18:41:41'!
PASSED!

!testRun: #CharacterTest #testIsCharacter stamp: 'MO 9/29/2022 18:41:41'!
PASSED!

!testRun: #CharacterTest #testSomeLatinCharsFromUtf8 stamp: 'MO 9/29/2022 18:41:41'!
PASSED!

!testRun: #CharacterTest #testSomeLatinCharsToUtf8 stamp: 'MO 9/29/2022 18:41:41'!
PASSED!

!testRun: #CharacterTest #testSorting stamp: 'MO 9/29/2022 18:41:41'!
PASSED!

!testRun: #CharacterTest #testTestingMethods stamp: 'MO 9/29/2022 18:41:41'!
PASSED!

!testRun: #CharacterTest #testToUtf8 stamp: 'MO 9/29/2022 18:41:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 18:41:43'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 18:42:01'!
ERROR!
!String methodsFor: 'converting' stamp: 'MO 9/29/2022 18:42:15'!
asRot13
	self shouldBeImplemented.! !
!String methodsFor: 'converting' stamp: 'MO 9/29/2022 18:42:31' prior: 50554741!
asRot13
	self subclassResponsibility! !

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 18:42:35'!
ERROR!
!String methodsFor: 'converting' stamp: 'MO 9/29/2022 18:42:59' prior: 50554745!
asRot13! !

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 18:43:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:43:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 18:43:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 18:43:05'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 18:43:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:43:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 18:43:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 18:43:11'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:43:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 18:43:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:43:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 18:43:13'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:43:13'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 18:43:13'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 18:43:13'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:43:13'!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 18:43:13'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 18:43:25'!
FAILURE!
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 18:45:01' prior: 50554701!
asRot13

	"self = $ ifTrue: [^ $]."
	self = '' ifTrue: [^ ''].
	self = $A ifTrue: [^ $N].
	self = $M ifTrue: [^ $Z].
	self = $N ifTrue: [^ $A].
	self = $Z ifTrue: [^ $M].
	self = ${ ifTrue: [^ ${].
	self = $` ifTrue: [^ $`].
	self = $z ifTrue: [^ $m].
	self = $n ifTrue: [^ $a].
	self = $m ifTrue: [^ $z].
	^ self! !

$a asciiValue!

$a asciiValue!

$a asciiValue!

97 asCharacter !
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 18:53:38' prior: 50554913!
asRot13

	"self = $ ifTrue: [^ $]."
	(self asciiValue) 	between: ($a asciiValue) and: ($m asciiValue) do: [^ (self asciiValue + 13) asCharacter].
	
	self = '' ifTrue: [^ ''].
	self = $A ifTrue: [^ $N].
	self = $M ifTrue: [^ $Z].
	self = $N ifTrue: [^ $A].
	self = $Z ifTrue: [^ $M].
	self = ${ ifTrue: [^ ${].
	self = $` ifTrue: [^ $`].
	self = $z ifTrue: [^ $m].
	self = $n ifTrue: [^ $a].
	self = $m ifTrue: [^ $z].
	^ self! !

!testRun: #CharacterTest #testCaseConversion stamp: 'MO 9/29/2022 18:53:40'!
PASSED!

!testRun: #CharacterTest #testFromUtf8 stamp: 'MO 9/29/2022 18:53:40'!
PASSED!

!testRun: #CharacterTest #testIsCharacter stamp: 'MO 9/29/2022 18:53:40'!
PASSED!

!testRun: #CharacterTest #testSomeLatinCharsFromUtf8 stamp: 'MO 9/29/2022 18:53:40'!
PASSED!

!testRun: #CharacterTest #testSomeLatinCharsToUtf8 stamp: 'MO 9/29/2022 18:53:40'!
PASSED!

!testRun: #CharacterTest #testSorting stamp: 'MO 9/29/2022 18:53:40'!
PASSED!

!testRun: #CharacterTest #testTestingMethods stamp: 'MO 9/29/2022 18:53:40'!
PASSED!

!testRun: #CharacterTest #testToUtf8 stamp: 'MO 9/29/2022 18:53:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 18:53:51'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:54:03'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:54:03'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:54:06'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:54:06'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:54:15'!
ERROR!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:54:15'!
ERROR!
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 18:55:12' prior: 50554928!
asRot13

	"self = $ ifTrue: [^ $]."
	((self asciiValue) 	between: ($a asciiValue) and: ($m asciiValue)) ifTrue: [^ (self asciiValue + 13) asCharacter].
	
	self = '' ifTrue: [^ ''].
	self = $A ifTrue: [^ $N].
	self = $M ifTrue: [^ $Z].
	self = $N ifTrue: [^ $A].
	self = $Z ifTrue: [^ $M].
	self = ${ ifTrue: [^ ${].
	self = $` ifTrue: [^ $`].
	self = $z ifTrue: [^ $m].
	self = $n ifTrue: [^ $a].
	self = $m ifTrue: [^ $z].
	^ self! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:55:14'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:55:14'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:55:14'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:55:14'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:55:14'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:55:14'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 18:55:14'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:55:15'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:55:15'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 18:55:15'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 18:55:15'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 18:55:15'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:55:20'!
PASSED!
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 18:56:46' prior: 50554996!
asRot13
	|selfAscii|
	"self = $ ifTrue: [^ $]."
	
	selfAscii := self asciiValue.
	
	(selfAscii 	between: ($a asciiValue) and: ($m asciiValue)) ifTrue: [^ (self asciiValue + 13) asCharacter].
	
	self = '' ifTrue: [^ ''].
	self = $A ifTrue: [^ $N].
	self = $M ifTrue: [^ $Z].
	self = $N ifTrue: [^ $A].
	self = $Z ifTrue: [^ $M].
	self = ${ ifTrue: [^ ${].
	self = $` ifTrue: [^ $`].
	self = $z ifTrue: [^ $m].
	self = $n ifTrue: [^ $a].
	self = $m ifTrue: [^ $z].
	^ self! !
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 18:57:18' prior: 50555066!
asRot13
	|selfAscii|
	"self = $ ifTrue: [^ $]."
	
	selfAscii := self asciiValue.
	
	(selfAscii 	between: ($a asciiValue) and: ($m asciiValue)) ifTrue: [^ (self asciiValue + 13) asCharacter].
	(selfAscii 	between: ($n asciiValue) and: ($z asciiValue)) ifTrue: [^ (self asciiValue - 13) asCharacter].
	
	self = '' ifTrue: [^ ''].
	self = $A ifTrue: [^ $N].
	self = $M ifTrue: [^ $Z].
	self = $N ifTrue: [^ $A].
	self = $Z ifTrue: [^ $M].
	self = ${ ifTrue: [^ ${].
	self = $` ifTrue: [^ $`].
	self = $z ifTrue: [^ $m].
	self = $n ifTrue: [^ $a].
	self = $m ifTrue: [^ $z].
	^ self! !

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:57:27'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 18:57:38' prior: 50554896!
test10CorrectlyEncodesAOneCharString
	
	"self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13"
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 18:57:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:57:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:57:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:57:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:57:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:57:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 18:57:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:57:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:57:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 18:57:39'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 18:57:39'!
PASSED!
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 18:59:21' prior: 50555084!
asRot13
	|selfAscii|
	"self = $ ifTrue: [^ $]."
	
	selfAscii := self asciiValue.
	
	((selfAscii 	between: ($a asciiValue) and: ($m asciiValue)) or:
	(selfAscii 	between: ($A asciiValue) and: ($M asciiValue))) ifTrue: [^ (self asciiValue + 13) asCharacter].
	(selfAscii 	between: ($n asciiValue) and: ($z asciiValue)) ifTrue: [^ (self asciiValue - 13) asCharacter].
	(selfAscii 	between: ($A asciiValue) and: ($A asciiValue)) ifTrue: [^ (self asciiValue + 13) asCharacter].
	self = '' ifTrue: [^ ''].
	self = $A ifTrue: [^ $N].
	self = $M ifTrue: [^ $Z].
	self = $N ifTrue: [^ $A].
	self = $Z ifTrue: [^ $M].
	self = ${ ifTrue: [^ ${].
	self = $` ifTrue: [^ $`].
	self = $z ifTrue: [^ $m].
	self = $n ifTrue: [^ $a].
	self = $m ifTrue: [^ $z].
	^ self! !

!testRun: #CharacterTest #testCaseConversion stamp: 'MO 9/29/2022 18:59:22'!
PASSED!

!testRun: #CharacterTest #testFromUtf8 stamp: 'MO 9/29/2022 18:59:22'!
PASSED!

!testRun: #CharacterTest #testIsCharacter stamp: 'MO 9/29/2022 18:59:22'!
PASSED!

!testRun: #CharacterTest #testSomeLatinCharsFromUtf8 stamp: 'MO 9/29/2022 18:59:22'!
PASSED!

!testRun: #CharacterTest #testSomeLatinCharsToUtf8 stamp: 'MO 9/29/2022 18:59:22'!
PASSED!

!testRun: #CharacterTest #testSorting stamp: 'MO 9/29/2022 18:59:22'!
PASSED!

!testRun: #CharacterTest #testTestingMethods stamp: 'MO 9/29/2022 18:59:22'!
PASSED!

!testRun: #CharacterTest #testToUtf8 stamp: 'MO 9/29/2022 18:59:22'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 18:59:24'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:59:24'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:59:24'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:59:24'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:59:24'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 18:59:24'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 18:59:24'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 18:59:24'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 18:59:24'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 18:59:24'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 18:59:24'!
PASSED!
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 19:00:12' prior: 50555164!
asRot13
	|selfAscii|
	"self = $ ifTrue: [^ $]."
	
	selfAscii := self asciiValue.
	
	((selfAscii 	between: ($a asciiValue) and: ($m asciiValue)) or:
	 (selfAscii 	between: ($A asciiValue) and: ($M asciiValue))) ifTrue: [^ (self asciiValue + 13) asCharacter].
	((selfAscii 	between: ($n asciiValue) and: ($z asciiValue)) or:
	 (selfAscii 	between: ($N asciiValue) and: ($Z asciiValue))) ifTrue: [^ (self asciiValue - 13) asCharacter].
	self = '' ifTrue: [^ ''].
	self = $A ifTrue: [^ $N].
	self = $M ifTrue: [^ $Z].
	self = $N ifTrue: [^ $A].
	self = $Z ifTrue: [^ $M].
	self = ${ ifTrue: [^ ${].
	self = $` ifTrue: [^ $`].
	self = $z ifTrue: [^ $m].
	self = $n ifTrue: [^ $a].
	self = $m ifTrue: [^ $z].
	^ self! !

!testRun: #CharacterTest #testCaseConversion stamp: 'MO 9/29/2022 19:00:14'!
PASSED!

!testRun: #CharacterTest #testFromUtf8 stamp: 'MO 9/29/2022 19:00:14'!
PASSED!

!testRun: #CharacterTest #testIsCharacter stamp: 'MO 9/29/2022 19:00:14'!
PASSED!

!testRun: #CharacterTest #testSomeLatinCharsFromUtf8 stamp: 'MO 9/29/2022 19:00:14'!
PASSED!

!testRun: #CharacterTest #testSomeLatinCharsToUtf8 stamp: 'MO 9/29/2022 19:00:14'!
PASSED!

!testRun: #CharacterTest #testSorting stamp: 'MO 9/29/2022 19:00:14'!
PASSED!

!testRun: #CharacterTest #testTestingMethods stamp: 'MO 9/29/2022 19:00:14'!
PASSED!

!testRun: #CharacterTest #testToUtf8 stamp: 'MO 9/29/2022 19:00:14'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:00:16'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:00:16'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:00:16'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:00:16'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:00:16'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:00:16'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:00:16'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:00:16'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:00:16'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:00:16'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:00:16'!
PASSED!
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 19:00:32' prior: 50555256!
asRot13
	|selfAscii|
	"self = $ ifTrue: [^ $]."
	
	selfAscii := self asciiValue.
	
	((selfAscii 	between: ($a asciiValue) and: ($m asciiValue)) or:
	 (selfAscii 	between: ($A asciiValue) and: ($M asciiValue))) ifTrue: [^ (self asciiValue + 13) asCharacter].
	((selfAscii 	between: ($n asciiValue) and: ($z asciiValue)) or:
	 (selfAscii 	between: ($N asciiValue) and: ($Z asciiValue))) ifTrue: [^ (self asciiValue - 13) asCharacter].
	^ self! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:00:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:00:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:00:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:00:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:00:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:00:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:00:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:00:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:00:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:00:33'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:00:33'!
PASSED!
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 19:00:48' prior: 50555347!
asRot13

	|selfAscii|
	
	selfAscii := self asciiValue.
	
	((selfAscii 	between: ($a asciiValue) and: ($m asciiValue)) or:
	 (selfAscii 	between: ($A asciiValue) and: ($M asciiValue))) ifTrue: [^ (self asciiValue + 13) asCharacter].
	((selfAscii 	between: ($n asciiValue) and: ($z asciiValue)) or:
	 (selfAscii 	between: ($N asciiValue) and: ($Z asciiValue))) ifTrue: [^ (self asciiValue - 13) asCharacter].
	^ self! !
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 19:00:52' prior: 50555408!
asRot13

	|selfAscii|
	
	selfAscii := self asciiValue.
	
	((selfAscii 	between: ($a asciiValue) and: ($m asciiValue)) or:
	 (selfAscii 	between: ($A asciiValue) and: ($M asciiValue))) ifTrue: [^ (self asciiValue + 13) asCharacter].
	((selfAscii 	between: ($n asciiValue) and: ($z asciiValue)) or:
	 (selfAscii 	between: ($N asciiValue) and: ($Z asciiValue))) ifTrue: [^ (self asciiValue - 13) asCharacter].
	
	^ self! !
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 19:02:16' prior: 50555110!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:02:26'!
FAILURE!

'n'!

'n'!

'n'!

String!

String !
!String methodsFor: '*TDDBabyStepsRot13Test' stamp: 'MO 9/29/2022 19:12:13' prior: 50554753!
asRot13
	| aString |
	
	aString := self.

	aString at: 1 put: ((aString at: 1) asRot13).
	
	^ aString
	
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:12:31'!
FAILURE!
!String methodsFor: '*TDDBabyStepsRot13Test' stamp: 'MO 9/29/2022 19:14:19' prior: 50555455!
asRot13
	| aString |
	
	self = '' ifTrue: [^ self].
	
	aString := self.

	aString at: 1 put: ((aString at: 1) asRot13).
	
	^ aString
	
	! !

!testRun: #StringTest #testAfterBlanksEndsWith stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testArticle stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testAsUtf8 stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testAsUtf8WithNCRs stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testBase64 stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testBeginsWith stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testCaseConversion stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testEncompassParagraph1 stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testEncompassParagraph2 stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testEncompassParagraph3 stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testEncompassParagraph4 stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testEncompassParagraph5 stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testFindSelector stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testFirstNonSeparator stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testIsString stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testLastNonSeparator stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testLineSeparators stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testSorting stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testWithBlanksTrimmed stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testWithoutLeadingBlanks stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testWithoutPrefix stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testWithoutSeparators stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #StringTest #testWithoutTrailingBlanks stamp: 'MO 9/29/2022 19:14:20'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:14:27'!
FAILURE!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 19:15:11' prior: 50555441!
test10CorrectlyEncodesAOneCharString
	
	"self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13"
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:15:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:15:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:15:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:15:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:15:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:15:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:15:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:15:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:15:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:15:12'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:15:12'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 19:15:52' prior: 50555536!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:15:53'!
FAILURE!

's' at: 1!

's' at: 1 put: $z!
!String methodsFor: '*TDDBabyStepsRot13Test' stamp: 'MO 9/29/2022 19:17:15' prior: 50555465!
asRot13
	| aString |
	
	self = '' ifTrue: [^ self].
	
	aString := self.

	aString at: 1 put: ((aString at: 1) asRot13).
	
	^ aString asString 
	
	! !

!testRun: #StringTest #testAfterBlanksEndsWith stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testArticle stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testAsUtf8 stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testAsUtf8WithNCRs stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testBase64 stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testBeginsWith stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testCaseConversion stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testEncompassParagraph1 stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testEncompassParagraph2 stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testEncompassParagraph3 stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testEncompassParagraph4 stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testEncompassParagraph5 stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testFindSelector stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testFirstNonSeparator stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testIsString stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testLastNonSeparator stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testLineSeparators stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testSorting stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testWithBlanksTrimmed stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testWithoutLeadingBlanks stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testWithoutPrefix stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testWithoutSeparators stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #StringTest #testWithoutTrailingBlanks stamp: 'MO 9/29/2022 19:17:16'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:17:25'!
FAILURE!
!String methodsFor: '*TDDBabyStepsRot13Test' stamp: 'MO 9/29/2022 19:19:36' prior: 50555604!
asRot13
	| aString |
	
	self = '' ifTrue: [^ self].
	
	aString := self.

	"aString at: 1 put: ((aString at: 1) asRot13)."
	
	^ aString first asRot13 asString 
	
	! !

!testRun: #StringTest #testAfterBlanksEndsWith stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testArticle stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testAsUtf8 stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testAsUtf8WithNCRs stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testBase64 stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testBeginsWith stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testCaseConversion stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testEncompassParagraph1 stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testEncompassParagraph2 stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testEncompassParagraph3 stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testEncompassParagraph4 stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testEncompassParagraph5 stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testFindSelector stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testFirstNonSeparator stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testIsString stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testLastNonSeparator stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testLineSeparators stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testSorting stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testWithBlanksTrimmed stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testWithoutLeadingBlanks stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testWithoutPrefix stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testWithoutSeparators stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #StringTest #testWithoutTrailingBlanks stamp: 'MO 9/29/2022 19:19:38'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:19:46'!
FAILURE!
!String methodsFor: '*TDDBabyStepsRot13Test' stamp: 'MO 9/29/2022 19:20:16' prior: 50555676!
asRot13
	"| aString |"
	
	self = '' ifTrue: [^ self].
	
	"aString := self."

	"aString at: 1 put: ((aString at: 1) asRot13)."
	
	^ self first asRot13 asString 
	
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:20:18'!
FAILURE!
!String methodsFor: '*TDDBabyStepsRot13Test' stamp: 'MO 9/29/2022 19:20:29' prior: 50555748!
asRot13
	"| aString |"
	
	self = '' ifTrue: [^ self].
	
	"aString := self."

	"aString at: 1 put: ((aString at: 1) asRot13)."
	
	^ (self first asRot13 asString)
	
	! !

!testRun: #StringTest #testAfterBlanksEndsWith stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testArticle stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testAsUtf8 stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testAsUtf8WithNCRs stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testBase64 stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testBeginsWith stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testCaseConversion stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testEncompassParagraph1 stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testEncompassParagraph2 stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testEncompassParagraph3 stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testEncompassParagraph4 stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testEncompassParagraph5 stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testFindSelector stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testFirstNonSeparator stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testIsString stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testLastNonSeparator stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testLineSeparators stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testSorting stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testWithBlanksTrimmed stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testWithoutLeadingBlanks stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testWithoutPrefix stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testWithoutSeparators stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #StringTest #testWithoutTrailingBlanks stamp: 'MO 9/29/2022 19:20:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:20:32'!
FAILURE!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:20:57'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:21:26'!
FAILURE!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 19:22:08' prior: 50555590!
test10CorrectlyEncodesAOneCharString
	
	"self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13."
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:22:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:22:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:22:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:22:09'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:22:09'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 19:22:13' prior: 50555840!
test10CorrectlyEncodesAOneCharString
	
	"self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13."
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:22:15'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:15'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:15'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:15'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:15'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:22:15'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:22:15'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:15'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:15'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:22:15'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:22:15'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 19:22:22' prior: 50555894!
test10CorrectlyEncodesAOneCharString
	
	"self assert: 'n' equals: 'a' asRot13."
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:22:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:22:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:22:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:22:23'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:22:23'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 19:22:28' prior: 50555948!
test10CorrectlyEncodesAOneCharString
	
	self assert: 'n' equals: 'a' asRot13.
	self assert: 'Z' equals: 'M' asRot13.
	self assert: 'a' equals: 'n' asRot13.
	self assert: '{' equals: '{' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:22:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:22:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:22:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:22:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:22:29'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:22:36'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:36'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:37'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:37'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:37'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:22:37'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:22:37'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:37'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:37'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:22:37'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:22:37'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:22:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:22:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:22:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:22:41'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:22:41'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 19:22:41'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 19:22:41'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 19:22:41'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 19:22:41'!
test11CorrectlyEncodesATwoCharString
	
	self assert: 'nm' equals: 'az' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 19:22:41'!
FAILURE!
!String methodsFor: '*TDDBabyStepsRot13Test' stamp: 'MO 9/29/2022 19:24:57' prior: 50555760!
asRot13
	"| aString |"
	
	self = '' ifTrue: [^ self].
	
	"aString := self."

	"aString at: 1 put: ((aString at: 1) asRot13)."
	
	^ self collect: [ :aChatacter | aChatacter asRot13].
	
	"^ (self first asRot13 asString)"
	
	! !

!testRun: #StringTest #testAfterBlanksEndsWith stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testArticle stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testAsUtf8 stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testAsUtf8WithNCRs stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testBase64 stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testBeginsWith stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testCaseConversion stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testEncompassParagraph1 stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testEncompassParagraph2 stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testEncompassParagraph3 stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testEncompassParagraph4 stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testEncompassParagraph5 stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testFindSelector stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testFirstNonSeparator stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testIsString stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testLastNonSeparator stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testLineSeparators stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testSorting stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testWithBlanksTrimmed stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testWithoutLeadingBlanks stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testWithoutPrefix stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testWithoutSeparators stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #StringTest #testWithoutTrailingBlanks stamp: 'MO 9/29/2022 19:24:59'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 19:25:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:25:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:25:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:25:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:25:01'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 19:25:01'!
PASSED!
!String methodsFor: '*TDDBabyStepsRot13Test' stamp: 'MO 9/29/2022 19:25:11' prior: 50556165!
asRot13
	"| aString |"
	
	"self = '' ifTrue: [^ self]."
	
	"aString := self."

	"aString at: 1 put: ((aString at: 1) asRot13)."
	
	^ self collect: [ :aChatacter | aChatacter asRot13].
	
	"^ (self first asRot13 asString)"
	
	! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 19:25:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:25:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:25:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:25:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:25:13'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 19:25:13'!
PASSED!
!String methodsFor: '*TDDBabyStepsRot13Test' stamp: 'MO 9/29/2022 19:25:48' prior: 50556283!
asRot13

	^ self collect: [ :aChatacter | aChatacter asRot13].
	
	! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 19:25:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:25:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:25:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:25:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:25:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 19:25:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:25:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:25:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:25:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:25:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:25:52'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 19:25:52'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 19:25:52'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'MO 9/29/2022 19:25:52'!
PASSED!

!methodRemoval: TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'MO 9/29/2022 19:25:52'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	!
!String methodsFor: '*TDDBabyStepsRot13Test' stamp: 'MO 9/29/2022 19:25:48' prior: 50556341!
asRot13

	^ self collect: [ :aChatacter | aChatacter asRot13].
	
	! !
!String methodsFor: '*TDDBabyStepsRot13Test' stamp: 'MO 9/29/2022 19:25:11' prior: 50556455!
asRot13
	"| aString |"
	
	"self = '' ifTrue: [^ self]."
	
	"aString := self."

	"aString at: 1 put: ((aString at: 1) asRot13)."
	
	^ self collect: [ :aChatacter | aChatacter asRot13].
	
	"^ (self first asRot13 asString)"
	
	! !
!String methodsFor: '*TDDBabyStepsRot13Test' stamp: 'MO 9/29/2022 19:29:33' prior: 50556461!
asRot13

	"| aString |"
	
	self size = 0 ifTrue: [^ self].
	
	self size = 1 ifTrue: [^ self first asRot13 asString].
	
	self size = 2 ifTrue: [^ self collect: [ :aChatacter | aChatacter asRot13]]
	
	"aString := self."

	"aString at: 1 put: ((aString at: 1) asRot13)."
	
	"^ self collect: [ :aChatacter | aChatacter asRot13]."
	
	! !

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 19:29:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:29:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:29:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:29:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:29:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:29:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:29:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:29:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:29:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:29:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:29:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 19:29:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:29:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:29:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:29:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:29:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:29:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:29:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:29:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:29:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:29:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:29:42'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 19:29:42'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 19:29:42'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'MO 9/29/2022 19:29:42'!
FAILURE!

!methodRemoval: TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'MO 9/29/2022 19:29:42'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 19:29:42'!
test12CorrectlyEncodesMoreThanTwoCharString
	
	self assert: 'uByN!!' equals: 'hOlA!!' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'MO 9/29/2022 19:29:42'!
FAILURE!
!String methodsFor: '*TDDBabyStepsRot13Test' stamp: 'MO 9/29/2022 19:30:25' prior: 50556472!
asRot13
	
	^ self collect: [ :aChatacter | aChatacter asRot13]
	
	! !

!testRun: #StringTest #testAfterBlanksEndsWith stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testArticle stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testAsUtf8 stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testAsUtf8WithNCRs stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testBase64 stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testBeginsWith stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testCaseConversion stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testEncompassParagraph1 stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testEncompassParagraph2 stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testEncompassParagraph3 stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testEncompassParagraph4 stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testEncompassParagraph5 stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testFindSelector stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testFirstNonSeparator stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testIsString stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testLastNonSeparator stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testLineSeparators stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testSorting stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testWithBlanksTrimmed stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testWithoutLeadingBlanks stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testWithoutPrefix stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testWithoutSeparators stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #StringTest #testWithoutTrailingBlanks stamp: 'MO 9/29/2022 19:30:27'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'MO 9/29/2022 19:30:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:30:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:30:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:30:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:30:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:30:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:30:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:30:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:30:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:30:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:30:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 19:30:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'MO 9/29/2022 19:30:28'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:30:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:30:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:30:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:30:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 19:30:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 19:30:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 19:30:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 19:30:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 19:30:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 19:30:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 19:30:30'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'MO 9/29/2022 19:30:30'!
PASSED!
!TDDBabyStepsRot13Test methodsFor: 'tests' stamp: 'MO 9/29/2022 19:30:30'!
testExtraToCheckGeneralizationOnKata
		
	self assert: 'Ju3er j3 4e3 t01at j3 q0ag a3rq e04q$...' equals: 'Wh3re w3 4r3 g01ng w3 d0nt n3ed r04d$...' asRot13
	! !

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'MO 9/29/2022 19:30:30'!
PASSED!

TDDBabyStepsGamePrimeFactors start!

!classDefinition: #TDDBabyStepsPrimeFactorsTest category: 'TDDBabyStepsGamePrimeFactors' stamp: 'MO 9/29/2022 19:33:05'!
TestCase subclass: #TDDBabyStepsPrimeFactorsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGamePrimeFactors'!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 19:33:13'!
test01OneHasNoPrimeFactors
	
	self assert: Bag new equals: 1 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 19:33:13'!
ERROR!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 19:33:13'!
test01OneHasNoPrimeFactors
	
	self assert: Bag new equals: 1 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 19:33:13'!
test01OneHasNoPrimeFactors
	
	self assert: Bag new equals: 1 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 19:33:13'!
ERROR!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 19:33:35'!
ERROR!
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'MO 9/29/2022 19:34:34'!
factorize
	self shouldBeImplemented.! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 19:34:43'!
ERROR!
!SmallInteger methodsFor: 'error handling' stamp: 'MO 9/29/2022 19:34:53' overrides: 16902107!
error: aString 
	self shouldBeImplemented.! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'MO 9/29/2022 19:35:52' prior: 50556815!
factorize
	
	
	^ Bag new! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'MO 9/29/2022 19:35:56' prior: 50556828!
factorize
	
	^ Bag new! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 19:35:57'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 19:35:57'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 19:36:01'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 19:36:01'!
test02FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 2) equals: 2 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:36:01'!
FAILURE!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:36:01'!
test02FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 2) equals: 2 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 19:36:01'!
test02FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 2) equals: 2 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:36:01'!
FAILURE!
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'MO 9/29/2022 19:36:39' prior: 50556832!
factorize
	
	self = 2 ifTrue: [^ (Bag with: 2)].
	^ Bag new! !

!testRun: #SmallIntegerTest #testBasicNew stamp: 'MO 9/29/2022 19:36:41'!
ERROR!

!testRun: #SmallIntegerTest #testBasicNew stamp: 'MO 9/29/2022 19:36:41'!
PASSED!

!testRun: #SmallIntegerTest #testDivide stamp: 'MO 9/29/2022 19:36:41'!
PASSED!

!testRun: #SmallIntegerTest #testEven stamp: 'MO 9/29/2022 19:36:41'!
PASSED!

!testRun: #SmallIntegerTest #testMaxVal stamp: 'MO 9/29/2022 19:36:41'!
PASSED!

!testRun: #SmallIntegerTest #testMinVal stamp: 'MO 9/29/2022 19:36:41'!
PASSED!

!testRun: #SmallIntegerTest #testNew stamp: 'MO 9/29/2022 19:36:41'!
ERROR!

!testRun: #SmallIntegerTest #testNew stamp: 'MO 9/29/2022 19:36:41'!
PASSED!

!testRun: #SmallIntegerTest #testOdd stamp: 'MO 9/29/2022 19:36:41'!
PASSED!

!testRun: #SmallIntegerTest #testPrintPaddedWith stamp: 'MO 9/29/2022 19:36:41'!
PASSED!

!testRun: #SmallIntegerTest #testPrintString stamp: 'MO 9/29/2022 19:36:41'!
PASSED!

!testRun: #SmallIntegerTest #testZeroRaisedToNegativePower stamp: 'MO 9/29/2022 19:36:41'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:36:42'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 19:36:42'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:36:42'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 19:36:44'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:36:44'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 19:36:44'!
test03FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 3) equals: 3 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:36:44'!
FAILURE!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:36:44'!
test03FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 3) equals: 3 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 19:36:44'!
test03FactorsOfAPrimeNumberAreThePrimeNumber

	self assert: (Bag with: 3) equals: 3 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:36:44'!
FAILURE!
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'MO 9/29/2022 19:37:02' prior: 50556874!
factorize
	
	self = 2 ifTrue: [^ (Bag with: 2)].
	self = 3 ifTrue: [^ (Bag with: 3)].
	^ Bag new! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:37:04'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 19:37:04'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:37:04'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:37:04'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 19:37:13'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:37:13'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:37:13'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 19:37:13'!
test04CorrectlyFactorizesACompositeNumberWithTwoFactors2
	
	self assert: (Bag with: 2 with: 2) equals: 4 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'MO 9/29/2022 19:37:13'!
FAILURE!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'MO 9/29/2022 19:37:13'!
test04CorrectlyFactorizesACompositeNumberWithTwoFactors2
	
	self assert: (Bag with: 2 with: 2) equals: 4 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 19:37:13'!
test04CorrectlyFactorizesACompositeNumberWithTwoFactors2
	
	self assert: (Bag with: 2 with: 2) equals: 4 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'MO 9/29/2022 19:37:13'!
FAILURE!
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'MO 9/29/2022 19:37:43' prior: 50556957!
factorize
	
	self = 2 ifTrue: [^ (Bag with: 2)].
	self = 3 ifTrue: [^ (Bag with: 3)].
	self = 4 ifTrue: [^ (Bag with: 2 with: 2)].
	^ Bag new! !

!testRun: #SmallIntegerTest #testBasicNew stamp: 'MO 9/29/2022 19:37:45'!
ERROR!

!testRun: #SmallIntegerTest #testBasicNew stamp: 'MO 9/29/2022 19:37:45'!
PASSED!

!testRun: #SmallIntegerTest #testDivide stamp: 'MO 9/29/2022 19:37:45'!
PASSED!

!testRun: #SmallIntegerTest #testEven stamp: 'MO 9/29/2022 19:37:45'!
PASSED!

!testRun: #SmallIntegerTest #testMaxVal stamp: 'MO 9/29/2022 19:37:45'!
PASSED!

!testRun: #SmallIntegerTest #testMinVal stamp: 'MO 9/29/2022 19:37:45'!
PASSED!

!testRun: #SmallIntegerTest #testNew stamp: 'MO 9/29/2022 19:37:45'!
ERROR!

!testRun: #SmallIntegerTest #testNew stamp: 'MO 9/29/2022 19:37:45'!
PASSED!

!testRun: #SmallIntegerTest #testOdd stamp: 'MO 9/29/2022 19:37:45'!
PASSED!

!testRun: #SmallIntegerTest #testPrintPaddedWith stamp: 'MO 9/29/2022 19:37:45'!
PASSED!

!testRun: #SmallIntegerTest #testPrintString stamp: 'MO 9/29/2022 19:37:45'!
PASSED!

!testRun: #SmallIntegerTest #testZeroRaisedToNegativePower stamp: 'MO 9/29/2022 19:37:45'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 19:38:00'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:38:00'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:38:00'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'MO 9/29/2022 19:38:00'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 19:38:00'!
test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2
	
	self assert: (Bag with: 2 with: 2 with: 2) equals: 8 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'MO 9/29/2022 19:38:00'!
FAILURE!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'MO 9/29/2022 19:38:00'!
test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2
	
	self assert: (Bag with: 2 with: 2 with: 2) equals: 8 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 19:38:00'!
test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2
	
	self assert: (Bag with: 2 with: 2 with: 2) equals: 8 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'MO 9/29/2022 19:38:00'!
FAILURE!
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'MO 9/29/2022 19:38:28' prior: 50557021!
factorize
	
	self = 2 ifTrue: [^ (Bag with: 2)].
	self = 3 ifTrue: [^ (Bag with: 3)].
	self = 4 ifTrue: [^ (Bag with: 2 with: 2)].
	self = 8 ifTrue: [^ (Bag with: 2 with: 2 with: 2)].
	^ Bag new! !

!testRun: #SmallIntegerTest #testBasicNew stamp: 'MO 9/29/2022 19:38:29'!
ERROR!

!testRun: #SmallIntegerTest #testBasicNew stamp: 'MO 9/29/2022 19:38:29'!
PASSED!

!testRun: #SmallIntegerTest #testDivide stamp: 'MO 9/29/2022 19:38:29'!
PASSED!

!testRun: #SmallIntegerTest #testEven stamp: 'MO 9/29/2022 19:38:29'!
PASSED!

!testRun: #SmallIntegerTest #testMaxVal stamp: 'MO 9/29/2022 19:38:29'!
PASSED!

!testRun: #SmallIntegerTest #testMinVal stamp: 'MO 9/29/2022 19:38:29'!
PASSED!

!testRun: #SmallIntegerTest #testNew stamp: 'MO 9/29/2022 19:38:29'!
ERROR!

!testRun: #SmallIntegerTest #testNew stamp: 'MO 9/29/2022 19:38:29'!
PASSED!

!testRun: #SmallIntegerTest #testOdd stamp: 'MO 9/29/2022 19:38:29'!
PASSED!

!testRun: #SmallIntegerTest #testPrintPaddedWith stamp: 'MO 9/29/2022 19:38:29'!
PASSED!

!testRun: #SmallIntegerTest #testPrintString stamp: 'MO 9/29/2022 19:38:29'!
PASSED!

!testRun: #SmallIntegerTest #testZeroRaisedToNegativePower stamp: 'MO 9/29/2022 19:38:29'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'MO 9/29/2022 19:38:31'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 19:38:31'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:38:31'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:38:31'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'MO 9/29/2022 19:38:31'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'MO 9/29/2022 19:38:31'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 19:38:34'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:38:34'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 19:38:34'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'MO 9/29/2022 19:38:34'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'MO 9/29/2022 19:38:34'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 19:38:34'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'MO 9/29/2022 19:38:34'!
FAILURE!

!methodRemoval: TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'MO 9/29/2022 19:38:34'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 19:38:34'!
test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2
	
	self assert: (Bag with: 3 with: 3) equals: 9 factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'MO 9/29/2022 19:38:34'!
FAILURE!

----End fileIn of /home/clinux01/Escritorio/linux64/Packages/TerseGuide.pck.st----!
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 20:01:02' prior: 50555425!
asRot13

	|selfAscii|
	
	selfAscii := self asLowercase asciiValue.
	
	((selfAscii 	between: ($a asciiValue) and: ($m asciiValue)) or:
	 (selfAscii 	between: ($A asciiValue) and: ($M asciiValue))) ifTrue: [^ (self asciiValue + 13) asCharacter].
	((selfAscii 	between: ($n asciiValue) and: ($z asciiValue)) or:
	 (selfAscii 	between: ($N asciiValue) and: ($Z asciiValue))) ifTrue: [^ (self asciiValue - 13) asCharacter].
	
	^ self! !
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 20:01:41' prior: 50560148!
asRot13

	|selfAscii|
	
	selfAscii := self asLowercase asciiValue.
	
	((selfAscii 	between: ($a asciiValue) and: ($m asciiValue)) "or:
	 (selfAscii 	between: ($A asciiValue) and: ($M asciiValue))") ifTrue: [^ (self asciiValue + 13) asCharacter].
	((selfAscii 	between: ($n asciiValue) and: ($z asciiValue)) or:
	 (selfAscii 	between: ($N asciiValue) and: ($Z asciiValue))) ifTrue: [^ (self asciiValue - 13) asCharacter].
	
	^ self! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 20:01:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 20:01:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 20:01:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 20:01:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 20:01:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 20:01:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 20:01:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 20:01:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 20:01:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 20:01:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 20:01:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'MO 9/29/2022 20:01:50'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'MO 9/29/2022 20:01:50'!
PASSED!
!Character methodsFor: '*TDDBabyStepsGameRot13' stamp: 'MO 9/29/2022 20:02:25' prior: 50560165!
asRot13

	|selfAscii|
	
	selfAscii := self asLowercase asciiValue.
	
	(selfAscii 	between: ($a asciiValue) and: ($m asciiValue)) ifTrue: [^ (self asciiValue + 13) asCharacter].
	(selfAscii 	between: ($n asciiValue) and: ($z asciiValue)) ifTrue: [^ (self asciiValue - 13) asCharacter].
	
	^ self! !

!testRun: #TDDBabyStepsRot13Test #test01CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 20:02:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test02CorrectlyEncodesALowercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 20:02:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test03CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 20:02:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test04CorrectlyEncodesALowercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 20:02:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test05CharOnTheBelowRangeDoesntChange stamp: 'MO 9/29/2022 20:02:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test06CharOnTheUpperRangeDoesntChange stamp: 'MO 9/29/2022 20:02:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test07CorrectlyEncodesAnUppercaseCharFromTheFirstPartOfTheAlphabet stamp: 'MO 9/29/2022 20:02:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test08CorrectlyEncodesAnUppercaseCharFromTheSecondPartOfTheAlphabet stamp: 'MO 9/29/2022 20:02:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test09TheEmptyStringDoesntChange stamp: 'MO 9/29/2022 20:02:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test10CorrectlyEncodesAOneCharString stamp: 'MO 9/29/2022 20:02:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test11CorrectlyEncodesATwoCharString stamp: 'MO 9/29/2022 20:02:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #test12CorrectlyEncodesMoreThanTwoCharString stamp: 'MO 9/29/2022 20:02:40'!
PASSED!

!testRun: #TDDBabyStepsRot13Test #testExtraToCheckGeneralizationOnKata stamp: 'MO 9/29/2022 20:02:40'!
PASSED!
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'MO 9/29/2022 20:09:51' prior: 50557108!
factorize
	
	|counter aBag aSelf|
	
	counter := 2.
	aSelf := self.
	aBag := Bag new.
	
	self timesRepeat: [
		(aSelf / counter) isInteger
			ifTrue: [aSelf := aSelf / counter.
				]
			ifFalse: [] ].
	
	^ Bag new
	"
	self = 2 ifTrue: [^ (Bag with: 2)].
	self = 3 ifTrue: [^ (Bag with: 3)].
	self = 4 ifTrue: [^ (Bag with: 2 with: 2)].
	self = 8 ifTrue: [^ (Bag with: 2 with: 2 with: 2)].
	^ Bag new"! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'MO 9/29/2022 20:10:02' prior: 50560297!
factorize
	
	|counter aBag aSelf|
	
	counter := 2.
	aSelf := self.
	aBag := Bag new.
	
	self timesRepeat: [
		(aSelf / counter) isInteger
			ifTrue: [aSelf := aSelf / counter.
				]
			ifFalse: [] ].
	
	^ aBag
	"
	self = 2 ifTrue: [^ (Bag with: 2)].
	self = 3 ifTrue: [^ (Bag with: 3)].
	self = 4 ifTrue: [^ (Bag with: 2 with: 2)].
	self = 8 ifTrue: [^ (Bag with: 2 with: 2 with: 2)].
	^ Bag new"! !
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'MO 9/29/2022 20:11:25' prior: 50560313!
factorize
	
	|counter aBag aSelf|
	
	counter := 2.
	aSelf := self.
	aBag := Bag new.
	
	self timesRepeat: [
		(aSelf / counter) isInteger
			ifTrue: [
				aSelf := aSelf / counter.
				aBag add: counter ]
			ifFalse: [
				counter := counter + 1 ] ].
	
	^ aBag
	"
	self = 2 ifTrue: [^ (Bag with: 2)].
	self = 3 ifTrue: [^ (Bag with: 3)].
	self = 4 ifTrue: [^ (Bag with: 2 with: 2)].
	self = 8 ifTrue: [^ (Bag with: 2 with: 2 with: 2)].
	^ Bag new"! !

!testRun: #SmallIntegerTest #testBasicNew stamp: 'MO 9/29/2022 20:11:26'!
ERROR!

!testRun: #SmallIntegerTest #testBasicNew stamp: 'MO 9/29/2022 20:11:26'!
PASSED!

!testRun: #SmallIntegerTest #testDivide stamp: 'MO 9/29/2022 20:11:26'!
PASSED!

!testRun: #SmallIntegerTest #testEven stamp: 'MO 9/29/2022 20:11:26'!
PASSED!

!testRun: #SmallIntegerTest #testMaxVal stamp: 'MO 9/29/2022 20:11:26'!
PASSED!

!testRun: #SmallIntegerTest #testMinVal stamp: 'MO 9/29/2022 20:11:26'!
PASSED!

!testRun: #SmallIntegerTest #testNew stamp: 'MO 9/29/2022 20:11:26'!
ERROR!

!testRun: #SmallIntegerTest #testNew stamp: 'MO 9/29/2022 20:11:26'!
PASSED!

!testRun: #SmallIntegerTest #testOdd stamp: 'MO 9/29/2022 20:11:26'!
PASSED!

!testRun: #SmallIntegerTest #testPrintPaddedWith stamp: 'MO 9/29/2022 20:11:26'!
PASSED!

!testRun: #SmallIntegerTest #testPrintString stamp: 'MO 9/29/2022 20:11:26'!
PASSED!

!testRun: #SmallIntegerTest #testZeroRaisedToNegativePower stamp: 'MO 9/29/2022 20:11:26'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'MO 9/29/2022 20:12:04'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 20:12:04'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 20:12:04'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 20:12:04'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'MO 9/29/2022 20:12:04'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'MO 9/29/2022 20:12:04'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'MO 9/29/2022 20:12:04'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test01OneHasNoPrimeFactors stamp: 'MO 9/29/2022 20:12:07'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test02FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 20:12:07'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test03FactorsOfAPrimeNumberAreThePrimeNumber stamp: 'MO 9/29/2022 20:12:07'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test04CorrectlyFactorizesACompositeNumberWithTwoFactors2 stamp: 'MO 9/29/2022 20:12:07'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test08CorrectlyFactorizesACompositeNumberWithMoreThanTwoFactors2 stamp: 'MO 9/29/2022 20:12:07'!
PASSED!

!testRun: #TDDBabyStepsPrimeFactorsTest #test09CorrectlyFactorizesACompositeNumberWithMoreThanOneFactorsDifferentThan2 stamp: 'MO 9/29/2022 20:12:07'!
PASSED!
!TDDBabyStepsPrimeFactorsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 20:12:07'!
testExtraToCheckGeneralizationOnKata
	
	self assert: (Bag with: 2 with: 2 with: 3 with: 3 with: 5 with: 13) equals: (2*2*3*3*5*13) factorize
	! !

!testRun: #TDDBabyStepsPrimeFactorsTest #testExtraToCheckGeneralizationOnKata stamp: 'MO 9/29/2022 20:12:07'!
PASSED!
!SmallInteger methodsFor: 'as yet unclassified' stamp: 'MO 9/29/2022 20:12:18' prior: 50560329!
factorize
	
	|counter aBag aSelf|
	
	counter := 2.
	aSelf := self.
	aBag := Bag new.
	
	self timesRepeat: [
		(aSelf / counter) isInteger
			ifTrue: [
				aSelf := aSelf / counter.
				aBag add: counter ]
			ifFalse: [
				counter := counter + 1 ] ].
	
	^ aBag! !

TDDBabyStepsGameAnagrams start!

!classDefinition: #TDDBabyStepsAnagramsTest category: 'TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 20:16:33'!
TestCase subclass: #TDDBabyStepsAnagramsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'TDDBabyStepsGameAnagrams'!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 20:24:47'!
test01EmptyStringAnagramIsJustACollectionWithTheEmptyString

	self assert: (Set with: '') equals: '' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 20:24:47'!
ERROR!

!methodRemoval: TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 20:24:47'!
test01EmptyStringAnagramIsJustACollectionWithTheEmptyString

	self assert: (Set with: '') equals: '' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 20:24:47'!
test01EmptyStringAnagramIsJustACollectionWithTheEmptyString

	self assert: (Set with: '') equals: '' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 20:24:47'!
ERROR!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 20:25:25'!
ERROR!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 20:26:18'!
anagrams
	self shouldBeImplemented.! !
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 20:26:38' prior: 50560500!
anagrams
	^ ''! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 20:26:53'!
FAILURE!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 20:27:13' prior: 50560505!
anagrams
	^ (Set with: '')! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 20:27:15'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 20:27:15'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 20:27:17'!
PASSED!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 20:27:17'!
test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString

	self assert: (Set with:'a') equals: 'a' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 20:27:17'!
FAILURE!

!methodRemoval: TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 20:27:17'!
test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString

	self assert: (Set with:'a') equals: 'a' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 20:27:17'!
test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString

	self assert: (Set with:'a') equals: 'a' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 20:27:17'!
FAILURE!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 20:29:16' prior: 50560513!
anagrams

	^ (Set with: self)! !

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 20:29:18'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 20:29:18'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 20:29:18'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 20:29:20'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 20:29:20'!
PASSED!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 20:29:20'!
test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped

	self assert: (Set with:'ab' with: 'ba') equals: 'ab' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 20:29:20'!
FAILURE!

!methodRemoval: TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 20:29:20'!
test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped

	self assert: (Set with:'ab' with: 'ba') equals: 'ab' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 20:29:20'!
test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped

	self assert: (Set with:'ab' with: 'ba') equals: 'ab' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 20:29:20'!
FAILURE!

Set with:'ab' with: 'ba' with:'ab'!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 20:44:49' prior: 50560562!
anagrams

	| aSet |
	
	aSet := Set with: self.

	(self size - 1) factorial timesRepeat: [
		
		aSet add: (self second, self first) asString
		
		].

	^ aSet! !

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 20:44:51'!
ERROR!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 20:45:28' prior: 50560623!
anagrams

	| aSet |
	
	aSet := Set with: self.

	(self size - 1) factorial timesRepeat: [
		
		aSet add: (self second asString, self first asString)
		
		].

	^ aSet! !

!testRun: #StringTest #testAfterBlanksEndsWith stamp: 'MO 9/29/2022 20:45:29'!
PASSED!

!testRun: #StringTest #testArticle stamp: 'MO 9/29/2022 20:45:29'!
PASSED!

!testRun: #StringTest #testAsUtf8 stamp: 'MO 9/29/2022 20:45:29'!
PASSED!

!testRun: #StringTest #testAsUtf8WithNCRs stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testBase64 stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testBeginsWith stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testCaseConversion stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testEncompassParagraph1 stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testEncompassParagraph2 stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testEncompassParagraph3 stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testEncompassParagraph4 stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testEncompassParagraph5 stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testFindSelector stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testFirstNonSeparator stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testIsString stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testLastNonSeparator stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testLineSeparators stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testSorting stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testWithBlanksTrimmed stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testWithoutLeadingBlanks stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testWithoutPrefix stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testWithoutSeparators stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #StringTest #testWithoutTrailingBlanks stamp: 'MO 9/29/2022 20:45:30'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 20:45:32'!
PASSED!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 20:45:55' prior: 50560636!
anagrams

	| aSet |
	
	aSet := Set with: self.

	(self size - 1) factorial timesRepeat: [
		
		aSet add: (self second asString, (self first asString))
		
		].

	^ aSet! !

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 20:45:57'!
PASSED!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 20:47:00' prior: 50560709!
anagrams

	| aSet |
	
	aSet := Set with: self.

	(self size) factorial timesRepeat: [
		
		aSet add: (self second asString, (self first asString))
		
		].

	^ aSet! !

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 20:47:02'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 20:47:02'!
ERROR!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 20:47:02'!
ERROR!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 20:47:02'!
PASSED!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 20:47:38' prior: 50560722!
anagrams

	| aSet |
	
	aSet := Set with: self.

	self size timesRepeat: [
		
		aSet add: (self second asString, (self first asString))
		
		].

	^ aSet! !

!testRun: #StringTest #testAfterBlanksEndsWith stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testArticle stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testAsUtf8 stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testAsUtf8WithNCRs stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testBase64 stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testBeginsWith stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testCaseConversion stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testEncompassParagraph1 stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testEncompassParagraph2 stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testEncompassParagraph3 stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testEncompassParagraph4 stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testEncompassParagraph5 stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testFindSelector stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testFirstNonSeparator stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testIsString stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testLastNonSeparator stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testLineSeparators stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testSorting stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testWithBlanksTrimmed stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testWithoutLeadingBlanks stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testWithoutPrefix stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testWithoutSeparators stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #StringTest #testWithoutTrailingBlanks stamp: 'MO 9/29/2022 20:47:39'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 20:47:41'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 20:47:41'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 20:47:41'!
ERROR!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 20:47:41'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 20:47:41'!
ERROR!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 20:47:58' prior: 50560749!
anagrams

	| aSet |
	
	aSet := Set with: self.

	(self size - 1) timesRepeat: [
		
		aSet add: (self second asString, (self first asString))
		
		].

	^ aSet! !

!testRun: #StringTest #testAfterBlanksEndsWith stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testArticle stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testAsUtf8 stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testAsUtf8WithNCRs stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testBase64 stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testBeginsWith stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testCaseConversion stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testEncompassParagraph1 stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testEncompassParagraph2 stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testEncompassParagraph3 stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testEncompassParagraph4 stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testEncompassParagraph5 stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testFindSelector stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testFirstNonSeparator stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testIsString stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testLastNonSeparator stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testLineSeparators stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testSorting stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testWithBlanksTrimmed stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testWithoutLeadingBlanks stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testWithoutPrefix stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testWithoutSeparators stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #StringTest #testWithoutTrailingBlanks stamp: 'MO 9/29/2022 20:47:59'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 20:48:01'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 20:48:01'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 20:48:01'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 20:48:01'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 20:48:15'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 20:48:15'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 20:48:15'!
PASSED!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 20:48:15'!
test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.

	self assert: anagrams equals: 'abc' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'MO 9/29/2022 20:48:15'!
FAILURE!

!methodRemoval: TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'MO 9/29/2022 20:48:15'!
test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.

	self assert: anagrams equals: 'abc' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 20:48:15'!
test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'bac'.
	anagrams add: 'bca'.
	anagrams add: 'cab'.
	anagrams add: 'cba'.

	self assert: anagrams equals: 'abc' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'MO 9/29/2022 20:48:15'!
FAILURE!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:01:55' prior: 50560840!
anagrams

	| aSet aSelf |
	
	aSelf := self.
	aSet := Set with: aSelf.

	"
	hacer esto self size veces
		mover de a 1 el primer elemento hasta el final (size-1 veces)
		swap:with:
	"

	self size timesRepeat: [
		1 to: (self size - 1) do: [ :anIndex | 
			aSelf swap:anIndex with: (anIndex + 1).
			aSet add: aSelf ].					
		"aSet add: (self second asString, (self first asString))"
		].

	^ aSet! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'MO 9/29/2022 21:02:05'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:02:25'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:02:25'!
FAILURE!

Set with:'ab' with: 'ba'; add:'ab'!

Set with:'ab' with: 'ba'; add:'ab'; yourself.!

	anagrams add: 'abc'.!

| anagrams |
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'abc'.!

| anagrams |
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'abc'.!

| anagrams |
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'abc'.!

| anagrams |
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'abc'.!

| anagrams |
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'abc'.
	anagrams!

| anagrams |
	anagrams := Set new.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'acb'.
	anagrams add: 'acb'.
	anagrams!

| anagrams |
	anagrams := Set with: 'abc'.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'abc'.
	anagrams add: 'acb'.
	anagrams add: 'acb'.
	anagrams add: 'acb'.
	anagrams!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:06:29' prior: 50560987!
anagrams

	| aSet aSelf |
	
	aSelf := self.
	aSet := Set with: aSelf.

	"
	hacer esto self size veces
		mover de a 1 el primer elemento hasta el final (size-1 veces)
		swap:with:
	"

	self size timesRepeat: [
		1 to: (self size - 1) do: [ :anIndex | 
			aSelf swap: anIndex with: (anIndex+1).
			aSet add: aSelf ].					
		"aSet add: (self second asString, (self first asString))"
		].

	^ aSet! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'MO 9/29/2022 21:06:31'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 21:06:35'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 21:06:37'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:06:40'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:06:40'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:08:04'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:08:11'!
PASSED!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:10:31' prior: 50561048!
anagrams

	| aSet aSelf |
	
	aSelf := self.
	aSet := Set with: aSelf.

	"
	hacer esto self size veces
		mover de a 1 el primer elemento hasta el final (size-1 veces)
		swap:with:
	"

	self size timesRepeat: [
		1 to: (self size) do: [ :anIndex | 
			aSelf swap: anIndex with: (anIndex+1).
			aSet add: aSelf ].					
		"aSet add: (self second asString, (self first asString))"
		].

	^ aSet! !
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:10:43' prior: 50561096!
anagrams

	| aSet aSelf |
	
	aSelf := self.
	aSet := Set with: aSelf.

	"
	hacer esto self size veces
		mover de a 1 el primer elemento hasta el final (size-1 veces)
		swap:with:
	"

	self size timesRepeat: [
		1 to: (self size-1) do: [ :anIndex | 
			aSelf swap: anIndex with: (anIndex+1).
			aSet add: aSelf ].					
		"aSet add: (self second asString, (self first asString))"
		].

	^ aSet! !

| aSet aSelf |
aSelf := 'ab'.
aSet := Set with: aSelf.
1 to: (aSelf size-1) do: [ :anIndex | 
			aSelf swap: anIndex with: (anIndex+1).
			aSet add: aSelf ].	
aSet!

| aSet aSelf |
aSelf := 'ab'.
aSet := Set with: aSelf.!

| aSet aSelf |
aSelf := 'ab'.
aSet := Set with: aSelf.
1 to: (aSelf size-1) do: [ :anIndex | aSelf swap: anIndex with: (anIndex+1). aSet add: aSelf ].	
aSet !
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:21:24' prior: 50561112!
anagrams

	| aSet aSelf |
	
	aSelf := self.
	aSet := Set with: aSelf.

	"
	hacer esto self size veces
		mover de a 1 el primer elemento hasta el final (size-1 veces)
		swap:with:
	"

	self size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					
					aSelf := aSelf swap: anIndex with: (anIndex+1).
					aSet add: aSelf ].	
				
		"aSet add: (self second asString, (self first asString)) aSelf"
		].

	^ aSet! !
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:21:32' prior: 50561140!
anagrams

	| aSet aSelf |
	
	aSelf := self.
	aSet := Set with: aSelf.

	"
	hacer esto self size veces
		mover de a 1 el primer elemento hasta el final (size-1 veces)
		swap:with:
	"

	self size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := aSelf swap: anIndex with: (anIndex+1).
					aSet add: aSelf ].	
				
		"aSet add: (self second asString, (self first asString)) aSelf"
		].

	^ aSet! !

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 21:21:45'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 21:21:48'!
PASSED!

| aSet aSelf |
aSelf := 'ab'.
aSet := Set with: aSelf.
aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := aSelf swap: anIndex with: (anIndex+1).
					aSet add: aSelf ].	
		].
aSet!

| aSet aSelf |
aSelf := 'ab'.
aSet := Set with: aSelf.
aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := aSelf swap: anIndex with: (anIndex+1).
					aSet add: 'entro' ].	
		].
aSet !

| aSet aSelf |
aSelf := 'ab'.
aSet := Set with: aSelf.
aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := (aSelf swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
aSet!

| aSet aSelf |
aSelf := 'ab'.
aSet := Set with: aSelf.
aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := (aSelf swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
aSelf!

| aSet aSelf |
aSelf := 'ab'.
aSet := Set with: aSelf.
aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := (aSelf swap: anIndex with: (anIndex+1)).
					aSet add: aSelf.
					aSelf.].	
		].
aSelf!

| aSet aSelf |
aSelf := 'ab'.
aSet := Set with: aSelf.
1 timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := (aSelf swap: anIndex with: (anIndex+1)).
					aSet add: aSelf.
					aSelf.].	
		].
aSelf!

| aSet aSelf |
aSelf := 'ab'.
aSet := Set with: aSelf.
1 timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := (aSelf swap: anIndex with: (anIndex+1)).
					aSet add: aSelf.
					aSelf.].	
		].
aSet!

| aSet aSelf |
aSelf := 'ab'.
aSet := Set with: aSelf.
1 timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := (aSelf swap: anIndex with: (anIndex+1)).
					aSelf copyTo: aSet.
					aSelf.].	
		].
aSet!

| aSet aSelf |
aSelf := 'ab'.
aSet := Set with: aSelf.
1 timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := (aSelf swap: anIndex with: (anIndex+1)).
					aSet add: aSelf.].	
		].
aSelf!

| aSet aSelf |
aSelf := 'ab'.
aSet := Set with: aSelf.
1 timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := (aSelf swap: anIndex with: (anIndex+1)).
					aSet add: aSelf.].	
		].
aSet!

| aSet aSelf |
aSelf := 'ab'.
aSet := Set with: aSelf.!

aSet.!

aSelf := 'ab'.!

aSet := Set with: aSelf.!

aSet.!

aSet!

aSet!

aSet add: 'ba'.!

aSet!

aSelf := 'ab'.!

aSet := Set with: aSelf.!

aSelf := (aSelf swap: 1 with: (2)).!

aSelf.!

aSet.!

aSelf := 'ab'.!

aSet := Set with: aSelf.!

aSelf!

aSelf copy!

aSelf := 'ab'.!

aSet := Set with: aSelf.!

aSet.!

aSelf := ((aSelf copy)swap: 1 with: (2)).!

aSelf.!

aSet.!

aSet add: aSelf.!

aSet.!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:39:18' prior: 50561157!
anagrams

	| aSet aSelf |
	
	aSelf := self.
	aSet := Set with: aSelf.

	"
	hacer esto self size veces
		mover de a 1 el primer elemento hasta el final (size-1 veces)
		swap:with:
	"

	self size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := (aSelf copy) swap: anIndex with: (anIndex+1).
					aSet add: aSelf ].	
		].

	^ aSet! !
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:39:52' prior: 50561264!
anagrams

	| aSet aSelf |
	
	aSelf := self.
	aSet := Set with: aSelf.

	"
	hacer esto self size veces
		mover de a 1 el primer elemento hasta el final (size-1 veces)
		swap:with:
	"

	self size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					"aSelf := (aSelf copy) swap: anIndex with: (anIndex+1)."
					aSelf reverse.
					aSet add: aSelf ].	
		].

	^ aSet! !

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 21:40:20'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 21:40:27'!
PASSED!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:41:02' prior: 50561278!
anagrams

	| aSet aSelf |
	
	aSelf := self.
	aSet := Set with: aSelf.

	"
	hacer esto self size veces
		mover de a 1 el primer elemento hasta el final (size-1 veces)
		swap:with:
	"

	self size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					"aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1))."
					"aSelf reverse."
					aSet add: ((aSelf copy) swap: anIndex with: (anIndex+1)) ].	
		].

	^ aSet! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 21:41:06'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 21:41:10'!
PASSED!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:42:11' prior: 50561302!
anagrams

	| aSet aSelf |
	
	aSelf := self.
	aSet := Set with: aSelf.

	"
	hacer esto self size veces
		mover de a 1 el primer elemento hasta el final (size-1 veces)
		swap:with:
	"

	aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					"aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1))."
					"aSelf reverse."
					aSet add: ((aSelf copy) swap: anIndex with: (anIndex+1)) ].	
		].

	^ aSet! !

aSelf := 'ab'.
aSet := Set with: aSelf.
aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					"aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1))."
					"aSelf reverse."
					aSet add: ((aSelf copy) swap: anIndex with: (anIndex+1)) ].	
		].
aSet!

aSelf := 'a'.
aSet := Set with: aSelf.
aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSet add: ((aSelf copy) swap: anIndex with: (anIndex+1)) ].	
		].
aSet !

aSelf := 'abc'.
aSet := Set with: aSelf.
aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSet add: ((aSelf copy) swap: anIndex with: (anIndex+1)) ].	
		].
aSet!

aSelf := 'ab'.
aSet := Set with: aSelf.
aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
aSet!

aSelf := 'a'.
aSet := Set with: aSelf.
aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
aSet!

aSelf := ''.
aSet := Set with: aSelf.
aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
aSet!

aSelf := 'abc'.
aSet := Set with: aSelf.
aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
aSet!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:45:30' prior: 50561327!
anagrams

	| aSet aSelf |
	
	aSelf := 'abc'.
	aSet := Set with: aSelf.
	aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
	aSet! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'MO 9/29/2022 21:45:36'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'MO 9/29/2022 21:45:36'!
FAILURE!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:45:43' prior: 50561389!
anagrams

	| aSet aSelf |
	
	aSelf := 'abc'.
	aSet := Set with: aSelf.
	aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
	^ aSet! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'MO 9/29/2022 21:45:46'!
PASSED!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:45:53' prior: 50561409!
anagrams

	| aSet aSelf |
	
	aSelf := self.
	aSet := Set with: aSelf.
	aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
	^ aSet! !

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'MO 9/29/2022 21:45:56'!
PASSED!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:46:18' prior: 50561425!
anagrams

	| aSet aSelf |
	
	aSelf := 'ab'.
	aSet := Set with: aSelf.
	aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
	^ aSet! !

aSelf := 'ab'.
aSet := Set with: aSelf.
aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
aSet!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:46:56' prior: 50561441!
anagrams

	| aSet aSelf |
	
	aSelf := 'ab'.
	aSet := Set with: aSelf.
	aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
	^ (Set with:'ab' with: 'ba')! !
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 21:47:09' prior: 50560609!
test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped

	self assert: (Set with:'ab' with: 'ba') equals: 'ab' anagrams! !

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:47:10'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 21:47:10'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 21:47:10'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:47:10'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'MO 9/29/2022 21:47:10'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:47:15'!
PASSED!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:47:25' prior: 50561458!
anagrams

	| aSet aSelf |
	
	aSelf := 'ab'.
	aSet := Set with: aSelf.
	aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
	^ aSelf! !

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:47:28'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:47:28'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:47:35'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:47:35'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 21:47:47'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 21:47:47'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:47:47'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'MO 9/29/2022 21:47:47'!
FAILURE!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:48:02' prior: 50561505!
anagrams

	| aSet aSelf |
	
	aSelf := self.
	aSet := Set with: aSelf.
	aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
	^ aSelf! !

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:48:04'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:48:08'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'MO 9/29/2022 21:48:39'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'MO 9/29/2022 21:48:39'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 21:48:51'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 21:48:51'!
FAILURE!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:49:01' prior: 50561553!
anagrams

	| aSet aSelf |
	
	aSelf := self.
	aSet := Set with: aSelf.
	aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
	^ aSet! !

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 21:49:03'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 21:49:03'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 21:49:03'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:49:03'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'MO 9/29/2022 21:49:03'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test01EmptyStringAnagramIsJustACollectionWithTheEmptyString stamp: 'MO 9/29/2022 21:49:11'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test02OneCharStringAnagramReturnsACollectionWithTheSameOneCharString stamp: 'MO 9/29/2022 21:49:11'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test03TwoCharStringAnagramReturnsTheOriginalStringAndAnotherOneFlipped stamp: 'MO 9/29/2022 21:49:11'!
PASSED!

!testRun: #TDDBabyStepsAnagramsTest #test04ThreeCharStringAnagramReturnsAllThe6PossibleOrderCombinations stamp: 'MO 9/29/2022 21:49:11'!
PASSED!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 21:49:11'!
test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abcd'; add: 'abdc'; add: 'acbd'; add: 'acdb'; add: 'adbc'; add: 'adcb'; add: 'bacd'; add: 'badc'; add: 'bcad'; add: 'bcda'; add: 'bdac'; add: 'bdca'; add: 'cabd'; add: 'cadb'; add: 'cbad'; add: 'cbda'; add: 'cdab'; add: 'cdba'; add: 'dabc'; add: 'dacb'; add: 'dbac'; add: 'dbca'; add: 'dcab'; add: 'dcba'.

	self assert: anagrams equals: 'abcd' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'MO 9/29/2022 21:49:11'!
FAILURE!

!methodRemoval: TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'MO 9/29/2022 21:49:11'!
test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abcd'; add: 'abdc'; add: 'acbd'; add: 'acdb'; add: 'adbc'; add: 'adcb'; add: 'bacd'; add: 'badc'; add: 'bcad'; add: 'bcda'; add: 'bdac'; add: 'bdca'; add: 'cabd'; add: 'cadb'; add: 'cbad'; add: 'cbda'; add: 'cdab'; add: 'cdba'; add: 'dabc'; add: 'dacb'; add: 'dbac'; add: 'dbca'; add: 'dcab'; add: 'dcba'.

	self assert: anagrams equals: 'abcd' anagrams
	!
!TDDBabyStepsAnagramsTest methodsFor: 'tests' stamp: 'MO 9/29/2022 21:49:11'!
test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations

	| anagrams |
	
	anagrams := Set new.
	anagrams add: 'abcd'; add: 'abdc'; add: 'acbd'; add: 'acdb'; add: 'adbc'; add: 'adcb'; add: 'bacd'; add: 'badc'; add: 'bcad'; add: 'bcda'; add: 'bdac'; add: 'bdca'; add: 'cabd'; add: 'cadb'; add: 'cbad'; add: 'cbda'; add: 'cdab'; add: 'cdba'; add: 'dabc'; add: 'dacb'; add: 'dbac'; add: 'dbca'; add: 'dcab'; add: 'dcba'.

	self assert: anagrams equals: 'abcd' anagrams
	! !

!testRun: #TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'MO 9/29/2022 21:49:11'!
FAILURE!

!testRun: #TDDBabyStepsAnagramsTest #test05MoreThanThreeCharStringAnagramReturnsAllTheCorrectPossibleOrderCombinations stamp: 'MO 9/29/2022 21:49:24'!
FAILURE!

aSelf := 'abcd'.
aSet := Set with: aSelf.
aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
aSet!
!String methodsFor: '*TDDBabyStepsGameAnagrams' stamp: 'MO 9/29/2022 21:53:04' prior: 50561591!
anagrams

	| aSet aSelf |
	
	aSelf := self.
	aSet := Set with: aSelf.
	
	aSelf size timesRepeat: [
		1 to: (aSelf size-1) do: [ :anIndex |
					aSelf := ((aSelf copy) swap: anIndex with: (anIndex+1)).
					aSet add: aSelf ].	
		].
	
	^ aSet! !

----STARTUP---- (10 November 2022 17:12:31) as /home/clinux01/Escritorio/CuisUniversity/CuisUniversity-5481.image!


----End fileIn of /home/clinux01/ingsoft-1011/10-CustomerImporter/CustomerImporter.st----!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:27:12' prior: 50552284!
test01Import

	| session |
	Customer importCustomers.
	
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:27:17' prior: 50552544!
test01Import

	| session |
	
	Customer importCustomers.
	
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:30:30' prior: 50552552!
test01Import

	| session |
	
	Customer importCustomers.
	
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 17:30:33'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 17:30:33'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:32:22' prior: 50552560!
test01Import

	| session |
	
	Customer importCustomers.
	
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.
	
	self assert: 2 equals: ((session selectAllOfType: Customer) size).
	
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 17:32:24'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 17:32:24'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:32:44' prior: 50552576!
test01Import

	
	
	Customer importCustomers.
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:32:57' prior: 50552593!
test01Import

	
	
	| session |
	Customer importCustomers.
	
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.
	
	self assert: 2 equals: ((session selectAllOfType: Customer) size).
	
	session commit.
	session close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:33:02' prior: 50552598!
test01Import

	| session |
	
	Customer importCustomers.
	
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.
	
	self assert: 2 equals: ((session selectAllOfType: Customer) size).
	
	session commit.
	session close.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:33:16' prior: 50552610!
test01Import

	| session |
	
	Customer importCustomers.
	
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.
	
	self assert: 2 equals: ((session selectAllOfType: Customer) size).
	
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 17:33:23'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 17:33:23'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:36:31' prior: 50552622!
test01Import

	| session |
	
	Customer importCustomers.
	
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	session commit.
	session close.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 17:36:51'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:38:13' prior: 50552639!
test01Import

	Customer importCustomers.! !
!ImportTest methodsFor: 'nil' stamp: 'SR 11/10/2022 17:40:05'!
importCustomers

	"
	self importCustomers
	"
	| inputStream session newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:40:16' prior: 50552653!
test01Import

	self importCustomers.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:42:33' prior: 50552698!
test01Import

	self importCustomers.
	
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:43:05' prior: 50552657!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.
	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !

!classDefinition: #ImportTest category: 'CustomerImporter' stamp: 'SR 11/10/2022 17:43:05'!
TestCase subclass: #ImportTest
	instanceVariableNames: 'session'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:44:43' overrides: 16961394!
setUp

	session := DataBaseSession for: (Array with: Address with: Customer).
	session beginTransaction! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:44:43' prior: 50552708!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.
	self setUp.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:45:00' prior: 50552763!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	session commit.
	session close.

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:45:19' overrides: 16961402!
tearDown

	session commit.
	session close! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:45:19' prior: 50552801!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	self tearDown.

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:45:24' prior: 50552844!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fourth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:45:56' prior: 50552703!
test01Import

	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 17:45:58'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:48:07' prior: 50552917!
test01Import

	| customer |
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := session
		select: [ :aCustomer | aCustomer identificationType = '22333444' ]
		ofType: Customer.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:49:06' prior: 50552926!
test01Import

	| customer |
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := session
		select: [ :aCustomer | aCustomer identificationType = '22333444' ]
		ofType: Customer.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:49:49' prior: 50552937!
test01Import

	| customer |
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 17:50:26'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:51:58' prior: 50552951!
test01Import

	| customer |
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 17:52:02'!
ERROR!
!Customer methodsFor: 'nil' stamp: 'SR 11/10/2022 17:52:25'!
numberOfAddresses

	^addresses size.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:52:30' prior: 50552969!
test01Import

	| customer |
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 17:55:20' prior: 50552992!
test01Import

	| customer address |
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].
	
	self assert: 'San Martin' equals: address streetName.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 17:55:29'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:04:17' prior: 50553009!
test01Import

	| customer address |
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.! !
!Customer methodsFor: 'nil' stamp: 'SR 11/10/2022 18:06:26'!
addressAt: aStreet ifNone: exeptionBlock.

	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:09:04' prior: 50552881!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData fourth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:09:20' prior: 50553067!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:10:02' prior: 50553037!
test01Import

	| customer address |
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:11:43' prior: 50553139!
test01Import

	| customer address |
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:12:18' prior: 50553166!
test01Import

	| customer address |
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'CABA' equals: address province.
	
	
	customer := session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:13:16' prior: 50553202!
test01Import

	| customer address |
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'CABA' equals: address province.
	
	
	customer := session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:16:18'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:16:38'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:16:38'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:18:16' prior: 50553268!
test01Import

	| customer address |
	
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'CABA' equals: address province.
	
	
	customer := session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:20:05'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:20:05'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:20:47'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:20:48'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:21:28'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:21:29'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:31:46' prior: 50553331!
test01Import

	| customer address |
	
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'CABA' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:31:48'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:32:25' prior: 50553401!
test01Import

	| customer address |
	
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'CABA' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:32:26'!
ERROR!
!Customer methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:35:47' prior: 50553062!
addressAt: aStreet ifNone: exeptionBlock.

	^ addresses detect: [ :anAddress | anAddress isAt: aStreet]! !
!Customer methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:36:59' prior: 50553518!
addressAt: aStreet ifNone: exeptionBlock.

	^ addresses detect: [ :anAddress | anAddress isAt: aStreet] ifNone: [exeptionBlock] value! !
!Customer methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:37:06' prior: 50553525!
addressAt: aStreet ifNone: exeptionBlock.

	^ addresses detect: [ :anAddress | anAddress isAt: aStreet] ifNone: exeptionBlock value! !
!Address methodsFor: 'street' stamp: 'SR 11/10/2022 18:38:12'!
isAt: aStreetName

	^ streetName = aStreetName ! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:38:16'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:38:37'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:40:02'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:43:07'!
FAILURE!
!Customer methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:46:00' prior: 50553533!
addressAt: aStreet ifNone: exeptionBlock.

	^ addresses detect: [ :anAddress | anAddress isAt: aStreet] ifNone: exeptionBlock! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:46:59'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:47:00'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:47:19' prior: 50553459!
test01Import

	| customer address |
	
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:47:22'!
FAILURE!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:47:23'!
FAILURE!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:47:44' prior: 50553567!
test01Import

	| customer address |
	
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:48:16' prior: 50553628!
test01Import

	| customer address |
	
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:48:18'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:48:55' prior: 50553685!
test01Import

	| customer address |
	
	self importCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:49:02'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:49:03'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:57:23'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 18:57:23'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 18:59:47' prior: 50553103!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:00:18' prior: 50553810!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:01:38' prior: 50553846!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:02:14' prior: 50553880!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:02:51' prior: 50553914!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:03:48' prior: 50553950!
importCustomers

	"
	self importCustomers
	"
	| inputStream  newCustomer line |

	inputStream := StandardFileStream new open: 'input.txt' forWrite: false.

	line := inputStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := inputStream nextLine. ].

	inputStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:05:35' prior: 50553984!
importCustomers

	"
	self importCustomers
	"
	| newCustomer line |

	line := (StandardFileStream new open: 'input.txt' forWrite: false) nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := (StandardFileStream new open: 'input.txt' forWrite: false) nextLine. ].

	(StandardFileStream new open: 'input.txt' forWrite: false) close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:07:09'!
importCustomers: aStream

	"
	self importCustomers
	"
	| newCustomer line |

	line := (StandardFileStream new open: 'input.txt' forWrite: false) nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := (StandardFileStream new open: 'input.txt' forWrite: false) nextLine. ].

	(StandardFileStream new open: 'input.txt' forWrite: false) close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:07:09' prior: 50553744!
test01Import

	| customer address |
	
	self importCustomers: (StandardFileStream new open: 'input.txt' forWrite: false).
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!methodRemoval: ImportTest #importCustomers stamp: 'SR 11/10/2022 19:07:09'!
importCustomers

	"
	self importCustomers
	"
	| newCustomer line |

	line := (StandardFileStream new open: 'input.txt' forWrite: false) nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := (StandardFileStream new open: 'input.txt' forWrite: false) nextLine. ].

	(StandardFileStream new open: 'input.txt' forWrite: false) close.
	!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:07:09' prior: 50554058!
importCustomers: aStream

	"
	self importCustomers
	"
	| newCustomer line |

	line := aStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := aStream nextLine. ].

	aStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:08:40' prior: 50554096!
test01Import

	| customer address |
	
	self importCustomers: (StandardFileStream new open: 'input.txt' forWrite: false).
	
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:12:26' prior: 50554225!
test01Import

	| customer address |
	
	self importCustomers: (Stream on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:12:27'!
ERROR!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:12:54' prior: 50554284!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:12:56'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:12:57'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:13:05' prior: 50554348!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:13:06'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:13:07'!
PASSED!

!classDefinition: #CustomerImporter category: 'CustomerImporter' stamp: 'SR 11/10/2022 19:21:26'!
Object subclass: #CustomerImporter
	instanceVariableNames: 'session readStream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'CustomerImporter'!
!CustomerImporter class methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:21:26'!
from: aStream to: aSession
	^self new initializeFrom: aStream to: aSession! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:21:26'!
initializeFrom: aStream to: aSession
	session := aSession.
	readStream := aStream.! !
!CustomerImporter methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:21:26'!
importCustomers

	"
	self importCustomers
	"
	| newCustomer line |

	line := readStream nextLine.
	[ line notNil ] whileTrue: [
		(line beginsWith: 'C') ifTrue: [ | customerData |
			customerData := line findTokens: $,.
			newCustomer := Customer new.
			newCustomer firstName: customerData second.
			newCustomer lastName: customerData third.
			newCustomer identificationType: customerData fourth.
			newCustomer identificationNumber: customerData fifth.
			session persist: newCustomer ].

		(line beginsWith: 'A') ifTrue: [ | addressData newAddress |
			addressData := line findTokens: $,.
			newAddress := Address new.
			newCustomer addAddress: newAddress.
			newAddress streetName: addressData second.
			newAddress streetNumber: addressData third asNumber .
			newAddress town: addressData fourth.
			newAddress zipCode: addressData fifth asNumber .
			newAddress province: addressData sixth ].

		line := readStream nextLine. ].

	readStream close.
	! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:21:26' prior: 50554191!
importCustomers: aStream
	(CustomerImporter from: aStream to: session) importCustomers! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:21:53'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:24:37' prior: 50554415!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:25:11'!
of: customer

	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:25:11' prior: 50554545!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self of: customer.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:25:58'!
firstName: firstName of: customer

	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:25:58' prior: 50554614!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self firstName: aName of: customer.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!methodRemoval: ImportTest #of: stamp: 'SR 11/10/2022 19:25:58'!
of: customer

	self assert: 'Pepe' equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:26:13' prior: 50554673!
firstName: firstName of: customer

	self assert: firstName equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:26:35' prior: 50554681!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self firstName: 'Pepe' of: customer.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:27:12'!
firstName: firstName lastName: lastName of: customer

	self assert: firstName equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:27:12' prior: 50554755!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self firstName: 'Pepe' lastName: lastName of: customer.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!methodRemoval: ImportTest #firstName:of: stamp: 'SR 11/10/2022 19:27:12'!
firstName: firstName of: customer

	self assert: firstName equals: customer firstName.
	self assert: 'Sanchez' equals: customer lastName!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:27:23' prior: 50554815!
firstName: firstName lastName: lastName of: customer

	self assert: firstName equals: customer firstName.
	self assert: lastName equals: customer lastName! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:27:30' prior: 50554823!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self firstName: 'Pepe' lastName: 'Sanchez' of: customer.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:27:32'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:27:33'!
PASSED!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:28:00'!
assertFirstName: firstName andLastName: lastName of: customer

	self assert: firstName equals: customer firstName.
	self assert: lastName equals: customer lastName! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:28:00' prior: 50554898!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' andLastName: 'Sanchez' of: customer.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!methodRemoval: ImportTest #firstName:lastName:of: stamp: 'SR 11/10/2022 19:28:00'!
firstName: firstName lastName: lastName of: customer

	self assert: firstName equals: customer firstName.
	self assert: lastName equals: customer lastName!
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:30:20'!
of: address

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province! !
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:30:20' prior: 50554972!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' andLastName: 'Sanchez' of: customer.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self of: address.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:31:59'!
aStreetName: assertStreetName of: address

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:31:59' prior: 50555051!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' andLastName: 'Sanchez' of: customer.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self aStreetName: 'San Martin' of: address.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!methodRemoval: ImportTest #of: stamp: 'SR 11/10/2022 19:31:59'!
of: address

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province!
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:32:36'!
assertStreetName: assertStreetName of: address

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:32:36' prior: 50555116!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' andLastName: 'Sanchez' of: customer.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assertStreetName: 'San Martin' of: address.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!methodRemoval: ImportTest #aStreetName:of: stamp: 'SR 11/10/2022 19:32:36'!
aStreetName: assertStreetName of: address

	self assert: 'San Martin' equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province!
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:32:45' prior: 50555180!
assertStreetName: aStreetName of: address

	self assert: aStreetName equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province! !
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:33:31'!
assertStreetName: aStreetName streetNumber: aStreetNumber of: address

	self assert: aStreetName equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:33:31' prior: 50555193!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' andLastName: 'Sanchez' of: customer.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assertStreetName: 'San Martin' streetNumber: 3322 of: address.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!methodRemoval: ImportTest #assertStreetName:of: stamp: 'SR 11/10/2022 19:33:31'!
assertStreetName: aStreetName of: address

	self assert: aStreetName equals: address streetName.
	self assert: 3322 equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:33:31' prior: 50555270!
assertStreetName: aStreetName streetNumber: aStreetNumber of: address

	self assert: aStreetName equals: address streetName.
	self assert: aStreetNumber equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:33:44'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:33:45'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:34:20'!
assertStreetName: aStreetName streetNumber: aStreetNumber town: aTown of: address

	self assert: aStreetName equals: address streetName.
	self assert: aStreetNumber equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:34:20' prior: 50555283!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' andLastName: 'Sanchez' of: customer.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' of: address.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!methodRemoval: ImportTest #assertStreetName:streetNumber:of: stamp: 'SR 11/10/2022 19:34:20'!
assertStreetName: aStreetName streetNumber: aStreetNumber of: address

	self assert: aStreetName equals: address streetName.
	self assert: aStreetNumber equals: address streetNumber.
	self assert: 'Olivos' equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:34:20' prior: 50555367!
assertStreetName: aStreetName streetNumber: aStreetNumber town: aTown of: address

	self assert: aStreetName equals: address streetName.
	self assert: aStreetNumber equals: address streetNumber.
	self assert: aTown equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province! !
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:34:44'!
assertStreetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode of: address

	self assert: aStreetName equals: address streetName.
	self assert: aStreetNumber equals: address streetNumber.
	self assert: aTown equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:34:44' prior: 50555381!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' andLastName: 'Sanchez' of: customer.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 of: address.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!methodRemoval: ImportTest #assertStreetName:streetNumber:town:of: stamp: 'SR 11/10/2022 19:34:44'!
assertStreetName: aStreetName streetNumber: aStreetNumber town: aTown of: address

	self assert: aStreetName equals: address streetName.
	self assert: aStreetNumber equals: address streetNumber.
	self assert: aTown equals: address town.
	self assert: 1636 equals: address zipCode.
	self assert: 'BsAs' equals: address province!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:34:44' prior: 50555463!
assertStreetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode of: address

	self assert: aStreetName equals: address streetName.
	self assert: aStreetNumber equals: address streetNumber.
	self assert: aTown equals: address town.
	self assert: aZipCode equals: address zipCode.
	self assert: 'BsAs' equals: address province! !
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:35:37'!
assertStreetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode province: aProvice of: address

	self assert: aStreetName equals: address streetName.
	self assert: aStreetNumber equals: address streetNumber.
	self assert: aTown equals: address town.
	self assert: aZipCode equals: address zipCode.
	self assert: 'BsAs' equals: address province! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:35:37' prior: 50555477!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' andLastName: 'Sanchez' of: customer.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: address.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assert: 'Maipu' equals: address streetName.
	self assert: 888 equals: address streetNumber.
	self assert: 'Florida' equals: address town.
	self assert: 1122 equals: address zipCode.
	self assert: 'Buenos Aires' equals: address province.
	
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!methodRemoval: ImportTest #assertStreetName:streetNumber:town:zipCode:of: stamp: 'SR 11/10/2022 19:35:37'!
assertStreetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode of: address

	self assert: aStreetName equals: address streetName.
	self assert: aStreetNumber equals: address streetNumber.
	self assert: aTown equals: address town.
	self assert: aZipCode equals: address zipCode.
	self assert: 'BsAs' equals: address province!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:35:37' prior: 50555561!
assertStreetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode province: aProvice of: address

	self assert: aStreetName equals: address streetName.
	self assert: aStreetNumber equals: address streetNumber.
	self assert: aTown equals: address town.
	self assert: aZipCode equals: address zipCode.
	self assert: aProvice equals: address province! !
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:36:28' prior: 50555576!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' andLastName: 'Sanchez' of: customer.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: address.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assertStreetName: 'Maipu' streetNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires' of: address.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assert: 'Juan' equals: customer firstName.
	self assert: 'Perez' equals: customer lastName.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:36:29'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:36:30'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:37:17' prior: 50555662!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' andLastName: 'Sanchez' of: customer.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: address.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assertStreetName: 'Maipu' streetNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires' of: address.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Juan' andLastName: 'Perez' of: customer.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:37:19'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:37:19'!
PASSED!
!ImportTest methodsFor: 'private' stamp: 'SR 11/10/2022 19:39:52' prior: 50554963!
assertFirstName: firstName andLastName: lastName of: aCustomer

	self assert: firstName equals: aCustomer firstName.
	self assert: lastName equals: aCustomer lastName! !
!ImportTest methodsFor: 'private' stamp: 'SR 11/10/2022 19:39:57' prior: 50555777!
assertFirstName: firstName andLastName: aLastName of: aCustomer

	self assert: firstName equals: aCustomer firstName.
	self assert: aLastName equals: aCustomer lastName! !
!ImportTest methodsFor: 'private' stamp: 'SR 11/10/2022 19:40:05' prior: 50555785!
assertFirstName: aFirstName andLastName: aLastName of: aCustomer

	self assert: aFirstName equals: aCustomer firstName.
	self assert: aLastName equals: aCustomer lastName! !
!ImportTest methodsFor: 'private' stamp: 'SR 11/10/2022 19:42:17'!
assertFirstName: aFirstName andLastName: aLastName addressCount: anAddressCount of: aCustomer

	self assert: aFirstName equals: aCustomer firstName.
	self assert: aLastName equals: aCustomer lastName! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:42:17' prior: 50555720!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' andLastName: 'Sanchez' addressCount: 2 of: customer.
	
	self assert: 2 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: address.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assertStreetName: 'Maipu' streetNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires' of: address.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Juan' andLastName: 'Perez' addressCount: 2 of: customer.
	
	self assert: 1 equals: customer numberOfAddresses.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!methodRemoval: ImportTest #assertFirstName:andLastName:of: stamp: 'SR 11/10/2022 19:42:17'!
assertFirstName: aFirstName andLastName: aLastName of: aCustomer

	self assert: aFirstName equals: aCustomer firstName.
	self assert: aLastName equals: aCustomer lastName!
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:42:49' prior: 50555811!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' andLastName: 'Sanchez' addressCount: 2 of: customer.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: address.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assertStreetName: 'Maipu' streetNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires' of: address.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Juan' andLastName: 'Perez' addressCount: 1 of: customer.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !
!ImportTest methodsFor: 'private' stamp: 'SR 11/10/2022 19:43:09' prior: 50555801!
assertFirstName: aFirstName andLastName: aLastName addressCount: anAddressCount of: aCustomer

	self assert: anAddressCount equals: aCustomer numberOfAddresses.
	self assert: aFirstName equals: aCustomer firstName.
	self assert: aLastName equals: aCustomer lastName! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:43:10'!
PASSED!
!ImportTest methodsFor: 'private' stamp: 'SR 11/10/2022 19:43:26' prior: 50555921!
assertFirstName: aFirstName andLastName: aLastName addressCount: anAddressCount of: aCustomer

	self assert: aFirstName equals: aCustomer firstName.
	self assert: aLastName equals: aCustomer lastName.
	self assert: anAddressCount equals: aCustomer numberOfAddresses! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:43:28'!
PASSED!
!ImportTest methodsFor: 'private' stamp: 'SR 11/10/2022 19:43:49'!
assertFirstName: aFirstName lastName: aLastName addressCount: anAddressCount of: aCustomer

	self assert: aFirstName equals: aCustomer firstName.
	self assert: aLastName equals: aCustomer lastName.
	self assert: anAddressCount equals: aCustomer numberOfAddresses! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:43:49' prior: 50555872!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' lastName: 'Sanchez' addressCount: 2 of: customer.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: address.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assertStreetName: 'Maipu' streetNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires' of: address.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Juan' lastName: 'Perez' addressCount: 1 of: customer.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].

	self assert: 'Alem' equals: address streetName.
	self assert: 1122 equals: address streetNumber.
	self assert: 'CABA' equals: address town.
	self assert: 1001 equals: address zipCode.
	self assert: 'CABA' equals: address province.! !

!methodRemoval: ImportTest #assertFirstName:andLastName:addressCount:of: stamp: 'SR 11/10/2022 19:43:49'!
assertFirstName: aFirstName andLastName: aLastName addressCount: anAddressCount of: aCustomer

	self assert: aFirstName equals: aCustomer firstName.
	self assert: aLastName equals: aCustomer lastName.
	self assert: anAddressCount equals: aCustomer numberOfAddresses!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:44:01'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:44:02'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:44:47' prior: 50555960!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' lastName: 'Sanchez' addressCount: 2 of: customer.
	
	address := customer addressAt: 'San Martin' ifNone: [ self fail ].

	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: address.
	
	address := customer addressAt: 'Maipu' ifNone: [ self fail ].

	self assertStreetName: 'Maipu' streetNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires' of: address.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Juan' lastName: 'Perez' addressCount: 1 of: customer.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].
	
	self assertStreetName: 'Alem' streetNumber: 1122 town: 'CABA' zipCode: 1001 province: 'CABA' of: address.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:44:53'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:44:54'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:45:30' prior: 50556026!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' lastName: 'Sanchez' addressCount: 2 of: customer.

	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: customer.

	self assertStreetName: 'Maipu' streetNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires' of: customer.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Juan' lastName: 'Perez' addressCount: 1 of: customer.
	
	address := customer addressAt: 'Alem' ifNone: [ self fail ].
	
	self assertStreetName: 'Alem' streetNumber: 1122 town: 'CABA' zipCode: 1001 province: 'CABA' of: address.! !
!ImportTest methodsFor: 'private' stamp: 'SR 11/10/2022 19:46:19' prior: 50555647!
assertStreetName: aStreetName streetNumber: aStreetNumber town: aTown zipCode: aZipCode province: aProvice of: aCustomer
	
	| address |

	address := aCustomer addressAt: aStreetName ifNone: [ self fail ].
	
	self assert: aStreetName equals: address streetName.
	self assert: aStreetNumber equals: address streetNumber.
	self assert: aTown equals: address town.
	self assert: aZipCode equals: address zipCode.
	self assert: aProvice equals: address province! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:46:22'!
ERROR!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:46:23'!
ERROR!
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:46:44' prior: 50556076!
test01Import

	| customer address |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' lastName: 'Sanchez' addressCount: 2 of: customer.

	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: customer.

	self assertStreetName: 'Maipu' streetNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires' of: customer.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Juan' lastName: 'Perez' addressCount: 1 of: customer.
	
	self assertStreetName: 'Alem' streetNumber: 1122 town: 'CABA' zipCode: 1001 province: 'CABA' of: customer.! !
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:46:52' prior: 50556139!
test01Import

	| customer |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' lastName: 'Sanchez' addressCount: 2 of: customer.

	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: customer.

	self assertStreetName: 'Maipu' streetNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires' of: customer.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Juan' lastName: 'Perez' addressCount: 1 of: customer.
	
	self assertStreetName: 'Alem' streetNumber: 1122 town: 'CABA' zipCode: 1001 province: 'CABA' of: customer.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:46:56'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:46:56'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:47:26' prior: 50556178!
test01Import

	| customer |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' lastName: 'Sanchez' addressCount: 2 of: customer.
	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: customer.
	self assertStreetName: 'Maipu' streetNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires' of: customer.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Juan' lastName: 'Perez' addressCount: 1 of: customer.
	self assertStreetName: 'Alem' streetNumber: 1122 town: 'CABA' zipCode: 1001 province: 'CABA' of: customer.! !
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:50:30'!
findCustomerWithIDType

	^ (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne! !
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:50:30' prior: 50556222!
test01Import

	| customer |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' lastName: 'Sanchez' addressCount: 2 of: customer.
	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: customer.
	self assertStreetName: 'Maipu' streetNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires' of: customer.
	
	customer := self findCustomerWithIDType.
		
	self assertFirstName: 'Juan' lastName: 'Perez' addressCount: 1 of: customer.
	self assertStreetName: 'Alem' streetNumber: 1122 town: 'CABA' zipCode: 1001 province: 'CABA' of: customer.! !
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:51:15'!
findCustomerWithIDType: anIDType

	^ (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:51:15' prior: 50556269!
test01Import

	| customer |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' lastName: 'Sanchez' addressCount: 2 of: customer.
	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: customer.
	self assertStreetName: 'Maipu' streetNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires' of: customer.
	
	customer := self findCustomerWithIDType: 'C'.
		
	self assertFirstName: 'Juan' lastName: 'Perez' addressCount: 1 of: customer.
	self assertStreetName: 'Alem' streetNumber: 1122 town: 'CABA' zipCode: 1001 province: 'CABA' of: customer.! !

!methodRemoval: ImportTest #findCustomerWithIDType stamp: 'SR 11/10/2022 19:51:15'!
findCustomerWithIDType

	^ (session
		select: [ :aCustomer | aCustomer identificationType = 'C' and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:51:15' prior: 50556303!
findCustomerWithIDType: anIDType

	^ (session
		select: [ :aCustomer | aCustomer identificationType = anIDType and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne! !
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:52:06'!
findCustomerWithIDType: anIDType andIDNumber: anIDNumber 

	^ (session
		select: [ :aCustomer | aCustomer identificationType = anIDType and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne! !
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:52:06' prior: 50556313!
test01Import

	| customer |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := (session
		select: [ :aCustomer | aCustomer identificationType = 'D' and: [ aCustomer identificationNumber = '22333444'] ]
		ofType: Customer) anyOne.
		
	self assertFirstName: 'Pepe' lastName: 'Sanchez' addressCount: 2 of: customer.
	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: customer.
	self assertStreetName: 'Maipu' streetNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires' of: customer.
	
	customer := self findCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
		
	self assertFirstName: 'Juan' lastName: 'Perez' addressCount: 1 of: customer.
	self assertStreetName: 'Alem' streetNumber: 1122 town: 'CABA' zipCode: 1001 province: 'CABA' of: customer.! !

!methodRemoval: ImportTest #findCustomerWithIDType: stamp: 'SR 11/10/2022 19:52:06'!
findCustomerWithIDType: anIDType

	^ (session
		select: [ :aCustomer | aCustomer identificationType = anIDType and: [ aCustomer identificationNumber = '23-25666777-9'] ]
		ofType: Customer) anyOne!
!ImportTest methodsFor: 'as yet unclassified' stamp: 'SR 11/10/2022 19:52:06' prior: 50556366!
findCustomerWithIDType: anIDType andIDNumber: anIDNumber 

	^ (session
		select: [ :aCustomer | aCustomer identificationType = anIDType and: [ aCustomer identificationNumber = anIDNumber] ]
		ofType: Customer) anyOne! !
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:52:37' prior: 50556376!
test01Import

	| customer |
	
	self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA').
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := self findCustomerWithIDType: 'D' andIDNumber: '22333444'.
		
	self assertFirstName: 'Pepe' lastName: 'Sanchez' addressCount: 2 of: customer.
	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: customer.
	self assertStreetName: 'Maipu' streetNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires' of: customer.
	
	customer := self findCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
		
	self assertFirstName: 'Juan' lastName: 'Perez' addressCount: 1 of: customer.
	self assertStreetName: 'Alem' streetNumber: 1122 town: 'CABA' zipCode: 1001 province: 'CABA' of: customer.! !

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:52:44'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 19:52:45'!
PASSED!
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:53:35'!
importDefaultCustomers

	^ self importCustomers: (ReadStream on: 
'C,Pepe,Sanchez,D,22333444
A,San Martin,3322,Olivos,1636,BsAs
A,Maipu,888,Florida,1122,Buenos Aires
C,Juan,Perez,C,23-25666777-9
A,Alem,1122,CABA,1001,CABA')! !
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:53:35' prior: 50556431!
test01Import

	| customer |
	
	self importDefaultCustomers.
	
	self assert: 2 equals: (session selectAllOfType: Customer) size.
	
	customer := self findCustomerWithIDType: 'D' andIDNumber: '22333444'.
		
	self assertFirstName: 'Pepe' lastName: 'Sanchez' addressCount: 2 of: customer.
	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: customer.
	self assertStreetName: 'Maipu' streetNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires' of: customer.
	
	customer := self findCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.
		
	self assertFirstName: 'Juan' lastName: 'Perez' addressCount: 1 of: customer.
	self assertStreetName: 'Alem' streetNumber: 1122 town: 'CABA' zipCode: 1001 province: 'CABA' of: customer.! !
!ImportTest methodsFor: 'tests' stamp: 'SR 11/10/2022 19:54:04' prior: 50556478!
test01Import

	| customer |

	self importDefaultCustomers.

	self assert: 2 equals: (session selectAllOfType: Customer) size.

	customer := self findCustomerWithIDType: 'D' andIDNumber: '22333444'.

	self assertFirstName: 'Pepe' lastName: 'Sanchez' addressCount: 2 of: customer.
	self assertStreetName: 'San Martin' streetNumber: 3322 town: 'Olivos' zipCode: 1636 province: 'BsAs' of: customer.
	self assertStreetName: 'Maipu' streetNumber: 888 town: 'Florida' zipCode: 1122 province: 'Buenos Aires' of: customer.

	customer := self findCustomerWithIDType: 'C' andIDNumber: '23-25666777-9'.

	self assertFirstName: 'Juan' lastName: 'Perez' addressCount: 1 of: customer.
	self assertStreetName: 'Alem' streetNumber: 1122 town: 'CABA' zipCode: 1001 province: 'CABA' of: customer.! !

----SNAPSHOT----(10 November 2022 19:54:47) CuisUniversity-5481.image priorSource: 7059698!

----STARTUP---- (10 November 2022 22:59:28) as C:\Users\sarod\Desktop\windows64\CuisUniversity-5481.image!


!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 22:59:39'!
PASSED!

!testRun: #ImportTest #test01Import stamp: 'SR 11/10/2022 22:59:49'!
PASSED!